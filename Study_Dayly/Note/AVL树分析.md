上一篇文章介绍了 map multimap set multiset ，并且提到过 这些容器的 底层都是 **红黑树** 实现的

之前介绍过 什么是二叉搜索树，但是二叉搜索树有一个缺点就是 在特定的情况下插入数据，可能会创建一个单边树。这也是为什么 set 和 map 不使用二叉搜索树，而是用红黑树的原因。

红黑树是平衡二叉搜索树的一种。本篇文章介绍的数据结构 也是一种平衡二叉搜索树，但并不是 红黑树 而是 **AVL树**。

AVL树 是最早被设计出来的平衡二叉搜索树

# 平衡二叉搜索树

关于 平衡二叉搜索树，除了它是二叉搜索树之外，最重要的特点莫过于 平衡 

对二叉树而言 怎么样才算平衡？

平衡树：任意节点的子树的高度差的绝对值都小于等于 1

> 任意节点的子树高度差的绝对值都 <= 1，这句话是什么意思？
>
> 首先要明白 什么是节点的子树的高度差：
>
> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/202209052035064.png" alt="image-20220905203514009" style="zoom:80%;" />
>
> 以上面这棵二叉树为例：
>
> 1. 对于 3 节点，其左子树的高度为 3，右子树的高度为 2。则可以说，3 节点的子树的高度差 为 -1
> 2. 对于 5 节点，其左子树的高度为 1，右子树的高度为 2。则可以说，5 节点的子树的高度差 为 1
> 3. 对于 2 节点，其左子树的高度为 1，右子树的高度为 1。则可以说，2 节点的子树的高度差 为 0
>
> 也就是说，节点的子树的高度差，可以根绝节点的左右子树的高度来计算，且计算时 左子树高度为负数，右子树高度为正数
>
> 那么可以计算出上面这棵树的所有结点的高度差：
>
> 3：-1；	5：1；	6：0；	2：0；	7：0；	4：0；	1：-1；	0：0；
>
> 所有结点的子树高度差的绝对值都没有大于 1，所以可以说上面这棵树是一颗平衡树

那么 平衡二叉搜索树，就是在此树 满足二叉搜索树的结构规则的前提 下，还要满足平衡

即，一棵树同时满足这两个条件 就可以称此树是平衡二叉搜索树：

1. 任意节点的子树的高度差的绝对值都小于等于 1
2. 任意节点的左孩子恒小于此节点，右孩子恒大于此节点

## AVL 树

### 1. AVL树 的概念

构建二叉搜索树存在一个缺点是 如果数据有序或接近有序 构建二叉搜索树，构建完成时会发现此树为单支树，查找元素相当于在顺序表中查找，时间复杂度接近O(N)

两位俄罗斯的数学家 **G.M.Adelson-Velskii** 和 **E.M.Landis** 发明了一种解决上述问题的方法：**插入数据建立二叉搜索树的同时，通过调整节点关系 使每个结点的左右子树高度差不超过 1，进而建立出平衡二叉搜索树 可降低树的高度，从而减少平均搜索长度**

由 **G.M.Adelson-Velskii** 和 **E.M.Landis** 提出的此方法构建出的 平衡二叉搜索树，就被称为 AVL树

### 2. AVL树 节点的定义

AVL树的是一种三叉链结构，即 每个节点除左右孩子、数据之外，还存有父亲节点

为了方便得出每个节点的子树高度差，所以还可以存储一个变量来记录左右孩子的高度差，一般被称为 `平衡因子`

所以 `AVL树 的节点结构` 可以设计为：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/202209052153361.png" alt="image-20220905215307309" style="zoom:80%;" />

> 当然 在节点内存储平衡因子并不是必须的，也可以通过其他方法记录

### 3. AVL树 插入数据

AVL树 是平衡二叉搜索树，建立的过程 是在 `二叉搜索树的前提下`，调整节点构建出来的。而树的构建过程, 其实也就是树节点插入的过程

那么 AVL树 执行插入操作之后, 也就需要保证 结果树依旧是一个 AVL树, 不过 在插入新节点之前需要保证 树已经是 AVL树

所以, AVL树插入数据的过程可以大致分为 两个步骤：

1. 按照二叉搜索树的插入方式插入新节点
2. 分析节点的子树高度差，并进行调整

下面也按照这两个步骤来对 AVL树的插入操作进行分析：

> 1. 按照二叉搜索树的插入方式插入新节点
>
> 二叉搜索树的特点是：节点的左孩子比节点小, 节点的右孩子比节点大
>
> 所以 插入新节点就需要通过比较新节点与各个节点的大小, 找到合适的位置, 然后再将新节点连接到树中：
>
> ```cpp
> bool insert(const T& data) {
> 	// 首先按照 二叉搜索树的方式 查找插入位置并插入节点
> 	if (_root == nullptr) {
> 		// 树为空 插入节点 直接将新节点作为树的根
> 		_root = new Node(data);
> 		_root->_bf = 0;		// 只有根节点的树，根节点平衡因子为 0
> 
> 		return true;		// 插入成功，直接返回
> 	}
> 
> 	// 走到这里就说明需要 查找插入位置 了
> 	Node* cur = _root;	// 从根节点开始比较
> 	Node* parent = nullptr;	// 需要记录父亲节点 供插入时连接
> 	while (cur) {
> 		// 循环结束的条件是 cur为空，cur为空时就说明 插入位置找到了
> 		if (cur->_data > data) {
> 			// 插入值比当前节点值 小，则向左孩子找
> 			parent = cur;
> 			cur = cur->_pLeft;
> 		}
> 		else if (cur->_data < data) {
> 			// 插入值比当前节点值 大，则向右孩子找
> 			parent = cur;
> 			cur = cur->_pRight;
> 		}
> 		else {
> 			// 走到这里 说明数中已存在相同数据
> 			return false;
> 		}
> 	}
> 
>     // 出循环之后，cur 即为数据需要插入的位置
> 	cur = new Node(data);
> 	// 将cur与树连接起来
> 	if (data > parent->_data) {
> 		parent->_pRight = cur;		// 插入数据比父亲节点数据大，则插入到父亲节点的右孩子
> 	}
> 	else if (data < parent->_data) {
> 		parent->_pLeft = cur;			// 插入数据比父亲节点数据小，则插入到父亲节点的左孩子
> 	}
> 	// 三叉链结构，cur节点虚存储父亲节点
> 	cur->_pParent = parent;
>     }
> ```
>
> 二叉搜索树的插入已经轻车熟路了, 所以 AVL树插入数据 最重要的、也是最难理解的部分 其实是：
> `插入数据之后, 对各个节点的平衡因子的分析, 以及对不平衡树的平衡操作`

在树中插入新的结点之后, 很有可能会造成树的不平衡, 举几个简单的例子：

> 存在插入之后, 存在不会失衡的情况
>
> <img src="C:\Users\dxyt2\AppData\Roaming\Typora\typora-user-images\image-20221010233200183.png" alt="image-20221010233200183" style="zoom:67%;" /> <img src="C:\Users\dxyt2\AppData\Roaming\Typora\typora-user-images\image-20221010233309020.png" alt="image-20221010233309020" style="zoom:66%;" /> `7 节点平衡因子, 从 1或-1 到 0`
>
> <img src="C:\Users\dxyt2\AppData\Roaming\Typora\typora-user-images\image-20221010232811437.png" alt="image-20221010232811437" style="zoom:66%;" /> `7 节点平衡因子 从 0 到 1或-1`
>
> 当然也有 使树失去平衡的情况：
>
> <img src="C:\Users\dxyt2\AppData\Roaming\Typora\typora-user-images\image-20221010234431163.png" alt="image-20221010234431163" style="zoom:67%;" /> `21节点 平衡因子从 1 到 2`
>
> <img src="C:\Users\dxyt2\AppData\Roaming\Typora\typora-user-images\image-20221010235353398.png" alt="image-20221010235353398" style="zoom:67%;" /> `21节点 平衡因子从 -1 到 -2`
>
> 其实 AVL树插入新节点之后, 一些节点的平衡因子一定会发生变化, 进而可能会对整棵树产生一定的影响
>
> 如果 因为插入新节点 导致某个节点的平衡因子的绝对值 >1, 那么就说明树不平衡了, 需要进行调整
>
> 不过 在实际的插入过程中, `插入新节点之后` 首先要做的并不是调整树的平衡, `首先要做的是 调整新插入节点的祖先节点的平衡因子`
> 因为, 插入新节点会改变其位置的祖先节点的平衡因子
>
> 那么 插入新节点之后首先要解决的问题就是：`如何更新新节点的祖先节点的平衡因子？`
>
> 其实并不难, 因为 AVL树的节点结构是 三叉链的结构, 所以可以 `从新节点向上寻找父亲节点` 来进行更新。但 实际上并不是每一个祖先节点都需要更新平衡因子
>
> 对下面 这个稍微复杂的 刚插入一个新节点的 AVL树进行分析：
>
> <img src="C:\Users\dxyt2\AppData\Roaming\Typora\typora-user-images\image-20221011001953703.png" alt="image-20221011001953703" style="zoom:67%;" /> 黑色为未插入新节点的 AVL树, `绿、综、红表示在不同位置插入新节点`
>
> 1. 如果在 绿色 位置插入, 则 `31节点平衡因子 由 0 变为 -1, 进而 22节点平衡因子由 -1 变为 0`, 不再向上影响, 停止更新
> 2. 如果在 棕色 位置插入, 则 `46节点平衡因子 由 0 变为 -1, 进而 41节点平衡因子由 1 变为 2, 以 41节点为根的树失衡, 需要进行调节 保持平衡`
> 3. 如果在 红色 位置插入, 则 `77节点平衡因子 由 0 变为 -1, 进而 70节点平衡因子由 0 变为 1, 进而 82节点平衡因子由 -1 变为 -2, 以 82节点为根的树失衡, 需要进行调节 保持平衡`
>
> 可以发现, 当 
>
> 1. `祖先节点平衡因子的变化 会影响 更上层的祖先节点的平衡因子时, 会继续向上对祖先节点进行调节`
> 2. `某祖先节点的平衡因子变为 2或-2, 导致以此节点为根的树失衡时, 需要停下对此树进行调节, 以保持平衡`
> 3. `存在 一直向上更新祖先节点的平衡因子, 直到更新到整棵树的根节点 的可能`
>
> 根据这三种情况, 就可以分析出 如何向上更新祖先节点的平衡因子
>
> 1. 首先要记录 当前节点 和 节点的父亲节点
> 2. 如果当前节点 是 父亲节点的左孩子, 则父亲节点的平衡因子-1, 否则+1
> 3. 当父亲节点的平衡因子 变为 1或-1 时, 还会影响上层的祖先节点, 所以需要继续向上更新
> 4. 当父亲节点的平衡因子 变为 2或-2 时, 以此父亲节点为根的树失衡, 需要对此树进行调节
> 5. 当父亲节点的平衡因子 变为 0 时, 不会继续影响上层祖先节点, 所以停止向上更新
> 6. 因为 可能更新到整棵树的根节点, 所以循环需要设置到 根节点结束
>
> 经过分析, 可以更新祖先节点的平衡因子的操作可以这样写：
>
> ```cpp
> // cur 是插入后的新节点
> cur->_pParent = parent;
> 
> while (parent) {
> 	if (cur == parent->_pLeft)
> 		parent->_bf--;			// 新节点在父亲节点的左孩子，则父亲节点的左子树高度+1，则父亲节点的平衡因子-1
> 	else
> 		parent->_bf++;
> 
> 	// 更新完之后，就需要判断 需要继续更新 还是停止更新 或是调整平衡
> 	if (parent->_bf == 0) {
> 		// 不会再影响更上边的节点，可以结束
> 		break;
> 	}
> 	else if (parent->_bf == -1 || parent->_bf == 1) {
> 		// 可能会继续影响更高节点的平衡 所以需要更新parent 和 cur，进而继续更新祖先节点的平衡因子
> 		cur = cur->_pParent;
> 		parent = parent->_pParent;
> 	}
> 	else if (parent->_bf == -2 || parent->_bf == 2) {
> 		// 需要调整平衡了
> 
> 	}
> 	else {
> 		// 以上情况都是在 保证树已经是AVL树时 插入新节点
> 		// 如果不是 则会走到此处 触发断言 进而发现错误
> 		assert(false);
> 	}
> }
> ```
>
> 祖先节点的平衡因子更新完成之后, 就需要对失衡的树进行调节了
>
> 处理失衡的树, 我们采用的方法是：`旋转`
>
> 

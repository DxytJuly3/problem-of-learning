本篇文章是 C++ 模板的第二篇文章，第一篇文章简单介绍了模板的函数模板、类模板的相关定义及调用等

然而 从初始模板到这篇文章之间，已经介绍了C++中有关 string、vector、stack、queue、priority_queue、iterator的功能、实现等内容，相信 对模板已经有了一定的认识

但是模板还有一些问题没有解决，本篇文章就是对模板 提出问题和解决问题的

# 非类型模板参数

在一般的模板中，无论是函数模板还是类模板，他们的定义都是，像这样的：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220716232837542.png" alt="image-20220716232837542" style="zoom:67%;" />

模板参数都是 虚拟的，传参时都需要传类型，但是 在定义模板时，模板参数还有另一种形式

即，不传 类型，而是已经知道了类型 传数值，叫做非类型模板参数，并且 C++11 引入了一种使用非类型模板参数的容器 叫 array

## 什么是 非类型模板参数？

其实查看一下 array 容器的模板定义一眼就可以看出来什么是 非类型模板参数：
![image-20220716233342736](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220716233342736.png)

对，没错，**非类型模板参数就是已经知道类型的模板参数**。使用这个模板 在传参的时候，除了传类型之外，还要传入**指定类型的数值**

> 其实 非类型模板参数只能传入整型数值：size_t、int、char

而在 array 这个容器中，size_t N 这个模板参数的作用，是为了定义一个大小为N的数组准备的，并且这个数组是静态的，与C语言中原生定义的数组没有什么区别：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220716234201918.png" alt="image-20220716234201918" style="zoom:67%;" />

也就是说，在容器 array 中，存在的非类型模板参数是为了指定需要定义数组的大小

> array 这个容器，其实就是 C语言中的原生数组，只不过在C++中 封装实现了
>
> array 相比原生的数组，只有些许优势：
>
> 1. array 实例化的对象，边界检查更准确
上一篇文章 详细介绍了什么是多态 和 多态的使用等方面的问题。但是却留下了一个最大的疑问

***编译器是怎么实现多态调用的？***

本篇文章的内容 就是分析多态实现原理的。

# 多态实现原理

## 虚函数表

在 介绍菱形虚拟继承的时候，介绍了一张表：**虚基表**，此表内存储的是数据的相对偏移量。是在菱形虚拟继承中存在的。

而上一篇文章介绍了多态，介绍了一种函数 `virtual 虚函数` 

一个类中存在虚函数，那么此类就会多出一个指向另一个表的指针，此指针叫 ***虚表指针***，此表叫 ***虚函数表，也称虚表***

怎么证明，存在虚函数的类会有一个虚表指针呢？

下面有一道面试题：

> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726134930627.png" alt="image-20220726134930627" style="zoom:80%;" />
>
> 上述类，**`sizeof(Base)`** 是多少？
>
> 按照类和对象的基础知识，**类成员函数不在类中 不占类空间，所以只计算 成员变量的大小，最总结果为 4**
>
> 但是实际查看会发现：
> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726135319978.png" alt="image-20220726135319978" style="zoom:80%;" />
>
> **Base 类的大小为 8(32位环境)**
>
> 这是为什么？查看Base 类对象内容：
>
> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726135849223.png" alt="image-20220726135849223" style="zoom:80%;" />
>
> 可以看到，除成员变量 _b 之外，还存在一个指针 指向了一张表，并且 **这个指针处于类对象的开头位置**
>
> 这个指针就是 **虚表指针**，指向的表就是**虚表**

虚表是干什么的？仔细观察虚表的内容，可以看出，**虚表内存储的是 类中所以虚函数的指针**，但是 在介绍类和对象的文章中就提到过，成员函数都是一起放在一个公共代码段的，所以其实 **虚函数并不是另外存储到了虚表中**

也就是说 虚表指针指向的**虚表 其实只是集合了 虚函数的指针，而不是存储了虚函数**，这些**虚函数还是与普通的成员函数一起存放在一个公共代码段**

也就是说，虚表指针 指向了一个 **存放有虚函数指针的地址** 
(虚表指针是一个二级指针，`**虚表指针` 可以直接取到虚表中的第一个虚函数)

---

**拥有虚函数的类存在虚表指针，指向虚表，虚表内容是 虚函数指针**

如果 继承体系中 父子类虚函数构成了重写，子类虚表的内容会是什么呢？

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726142249999.png" alt="image-20220726142249999" style="zoom:80%;" />

对比子类和父类对象的内容：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726142135476.png" alt="image-20220726142135476" style="zoom:80%;" />

可以看到，子类对象中继承于父类的那一部分也有一个虚表指针

但是因为重写了父类虚函数，所以虚表内的虚函数指针 是被重写之后的虚函数的指针
并且，**没有重写的虚函数与父类中的相同**，所以 子类中的虚表也可以看作是 **复制父类的虚表然后覆盖了被重写的函数** ,但是并不是真的复制+覆盖

---

子类对象 虚表的内容与父类对象相比较，重写的虚函数覆盖了原虚函数

那么还有一个问题：**子类对象自己的虚函数指针 会存放在哪里呢？**

举个例子：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726144150670.png" alt="image-20220726144150670" style="zoom:80%;" />

使用上面的子类 实例化对象并查看对象的内容：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726144411368.png" alt="image-20220726144411368" style="zoom:80%;" />

在VS的监视窗口中，子类对象，**既没有新建一个虚表存放只属于自己的虚函数的指针，原虚表中也没有显示只属于自己的虚函数指针**

子类中 **只属于自己的虚函数的指针到底存放在了哪里** ？

监视窗口中没有显示，但是在介绍继承的时候说过，VS的监视窗口是经过软件优化过后的，会不会只是监视窗口没有显示，但 只属于自己的虚函数指针 其实也在原续编中存储呢？ 

监视窗口可以看到虚表的地址，由此就可以从内存窗口中查看到地址存储的内容：
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726145241845.png" alt="image-20220726145241845" style="zoom:80%;" />

可以看到，需表中确实存储了 虚函数指针，但是**第三个指针不能确定是否 是只属于子类的虚函数的指针**，需要验证

***怎么验证？***

**可以取出虚表中的指针，然后调用指针，如果能调用 且 执行结果符合函数，就说明是 子类虚函数指针**

32位环境下，对象的头四个字节即为虚表指针，**怎么取头四个字节？**

> 虚函数的返回值类型为 void，参数为空，所以 函数指针类型为 `void(* )()`
>
> 将 函数指针类型 typedef 一下：`typedef void(*VFTPTR )()` 
> `VFTPTR` 即为新名字，函数指针的特性
>
> 虚表指针是一个 指向函数地址的指针，所以 **`VFTPTR*` 即为函数指针的类型**
>
> 所以，取对象的地址，再将其 强转为 `int*` ，再解引用，即为对象的头4个字节的值，也就是虚表指针的地址
> 再将其强转为 `VFTPTR*`，再赋给 `VFTPTR*`类型的变量，此变量就是虚表指针：
>
> **`VFTPTR* vTable = (VFTPTR*)(*(int*)&dav);`**
>
> 然后将 虚表指针传入此函数中：
>
> ```cpp
> void PrintVTable(VFTPTR vTable[])
> {	// 虚表指针地址是一个二维数组，所以形参可以为 VFTPTR 类型的数组
> 	// 依次取虚表中的虚函数指针打印并调用。调用就可以看出存的是哪个函数
> 	cout << " 虚表地址>" << vTable << endl;
> 	for (int i = 0; vTable[i] != nullptr; ++i)
> 	{
> 		printf(" 第%d个虚函数地址 :0X%x,->", i, vTable[i]);
> 		VFTPTR f = vTable[i]; 		// 取函数指针
> 		f(); 						// 函数指针调用函数
> 	}
> 	cout << endl;
> }
> ```
>
> > 此函数循环体的结束标志是，遇到 `nullptr`
> > 是因为在VS 平台下，虚表的结尾是一个空指针
>
> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726152135478.png" alt="image-20220726152135478" style="zoom:80%;" />
>
> 继续调用函数：
>
> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726152400059.png" alt="image-20220726152400059" style="zoom:80%;" />
>
> 可以看到 函数指针调用函数，**第三个函数指针的执行结果确实与 子类自己的虚函数执行结果相同**
>
> 由此可以证明 **原虚函数表中确实存储了 属于子类自己的虚函数的指针，但是 VS的监视窗口中没有显示**
>
> > 个人感觉这是一个BUG

所以，其实 子类对象中 **无论是自己的虚函数 还是从父类中继承过来的虚函数**，无论重写与否，**其函数地址都存放在同一个虚函数表中**

总结，**虚函数表** 是存放类虚函数指针的一个表，此表不直接存储在对象中
而是在对象中存储一个指向 此表的指针，即 **虚表指针**

虚函数表的内容，会 **根据是否构成重写而发生变化**，这一变化是为多态的实现提供条件的

## 多态原理

分析了半天的虚函数表，说虚函数表是为多态的实现提供条件的，那么**多态究竟是怎么实现的？**

在上一篇文章中介绍过，多态需要满足两个条件：

1. 必须是**父类的指针** 或 **父类的引用** 来调用 ***虚函数***
2. 被调用的函数必须是 ***虚函数***，并且 此 ***虚函数*** 必须被 ***重写***

需要第二个条件的原由，其实在上面分析虚函数表时，已经得到答案了

***只有父类的虚函数被重写时，子类的虚函数表内 存储的才是 重写之后 的虚函数指针***
***否则，子类的虚函数表内 存储的依旧是 父类未被重写 的虚函数指针***

问题还剩一个，**为什么多态调用需要满足 父类指针或父类引用 调用虚函数？**

---

还是在C++继承的分析文章中，介绍过 **子类对象赋值给父类对象会发生切割**

并且延伸出

1. **子类对象的地址 可以切割给 父类指针**；
2. **子类对象 可以直接切割给 父类引用**

在多态的实现中，这两个性质 十分的重要：

以 买票的多态为例：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726185017441.png" alt="image-20220726185017441" style="zoom:80%;" />

当使用父类指针或父类引用接收子类的地址或对象时：

![image-20220726191641257](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726191641257.png)

可以发现：对象 `stu1`  和 `eld1` 的虚表内存储的都是 **重写后的虚函数的指针**
并且，父类指针 `ptrPer` 指向的就是 `stu1 的父类部分`；父类引用 `quoPer` 就是 `eld1父类部分的别名`

这样就可以赋予 父类指针 或 父类引用 不同的对象，来多态调用虚函数：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726192409169.png" alt="image-20220726192409169" style="zoom:80%;" />

但这只是满足了多态调用的两个条件。**编译器是如何选择多态调用还是普通调用的？**

用以下类 举个例子：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726231928693.png" alt="image-20220726231928693" style="zoom:80%;" />

`Advanced类`中的 `Func1` 重写了` Base类`中的 `Func1`，此时：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726232434061.png" alt="image-20220726232434061" style="zoom:80%;" />

由于 `ptrBas` 只是 `Advanced对象`中的**`Base`部分的指针**，所以 它指向的内容并**没有 `Advanced`类中的`Func2`**
所以 执行`ptrBas->Func2()` 时，默认会**普通调用 `Base`类中的`Func2()`**

不同的是，`Func1` 在`Advanced类`中重写了，并且 其函数指针被存入了虚表中。但 其实`Base类`中也是有`Func1` 函数的，**为什么 调用时去虚表中找重写后的函数指针并调用，而不是普通调用`Base`中的`Func1`？**

其实没有具体的为什么。

为实现多态，C++编译器设计的就是：
**当调用函数满足多态两个条件时，编译器不会在 编译时 就根据类中的函数确认函数调用地址，而是在运行时 查找虚表 进而确认调用函数的地址**

这是C++编译器 **为了实现多态而设定的一种机制**，机制是固定且明确的：**函数调用满足多态的两个条件**

当满足条件时，编译器就不在编译时确定函数调用的地址，而是在运行时查表确定

---

### 如何证明，多态调用函数是在运行时才确定函数地址的，而不是在编译时？

VS环境下证明的方法有一个，那就是 **查看反汇编代码** (此汇编是一个动作而不是语言)

依旧按照上面例子的操作，查看其反汇编代码：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726234452222.png" alt="image-20220726234452222" style="zoom:80%;" />

首先可以非常明显的看到，多态调用 与 普通调用的反汇编代码的步骤是不一样的

尝试大致分析一下，两种调用方式 反汇编的意思：

> `dword` 为 4 字节

>  多态调用：
> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220727000215510.png" alt="image-20220727000215510" style="zoom:80%;" />
>
> 虽然具体意思不明确，但是大概意思还是可以看出来的
> 其实就是在**使用各种寄存器，找虚表，查虚表，然后找到函数地址了再call**
>
> 也就是说，程序再运行时 才去找函数地址了，能够说明 **多态调用函数，是在程序运行时才通过查表来确定函数地址的**

> 普通调用：
>
> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220727000717413.png" alt="image-20220727000717413" style="zoom:80%;" />
>
> 普通调用，直接就call了函数地址，也就是说运行时就已经知道了需要调用的函数的地址
>
> 所以 **普通调用是编译时就确定了函数的地址**

---

### 问题：为什么不能是 父类对象？

首先要先理解：

把子类对象 或 子类对象的地址 赋值给 父类引用 或 父类指针
并**不是创建了一个全新的父类对象**。而是由 父类指针指向子类对象的父类部分 或 直接给子类对象的父类部分去了别名。**本质上还是在子类对象上操作**的

但是 如果让 父类对象也可以实现多态
那么就需要 在子类对象给父类对象赋值的时候，将子类对象虚表内的 仅子类拥有的 已经重写后的虚函数指针 也赋值给父类对象。

这就导致了 **一个普通的父类对象 却 拥有了其他类的虚函数指针，合理吗？**

很明显是不合理的

如果一个普通的父类对象虚表内存储的是其子类对象的虚函数指针，那么自己的虚函数指针应该存储在哪里？

所以，不能让父类对象也实现多态，会错误、会混乱

# 多继承关系的虚函数表

上面的内容都是对于单继承关系虚函数表的

但是C++ 保留了多继承，那么就不得不继续介绍一下 多继承体系中子类的虚函数表的问题了

多继承体系中，子类继承了两个父类，那么父类的虚函数在子类对象中是怎么存在的呢？子类自己的虚函数在对象中又是怎么存在的呢？

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220728103126822.png" alt="image-20220728103126822" style="zoom:80%;" />

以上面这个继承体系为例，查看子类的内容：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220728104114303.png" alt="image-20220728104114303" style="zoom:80%;" />

从监视窗口可以看到，多继承子类对象中存在多张虚表(具体要看父类个数)

由于VS对虚表进行了优化，使用 查看虚表的函数查看这两张虚表：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220728104924827.png" alt="image-20220728104924827" style="zoom:80%;" />

> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220728104937477.png" alt="image-20220728104937477" style="zoom:80%;" />
>
> 取第二个虚表的地址
> 首先就是将对象地址跳过第一个父类的大小，获得第二个父类的地址
>
> 然后解引用，再转换为4字节的指针，再转换为函数指针

可以看到，两张虚表分别存储了父类的虚函数指针，并且**子类自己的虚函数指针是存储在第一张虚表内**的

但是，有没有发现**虚表中诡异的一点**？

明明是 `Advanced` 重写过的同一个函数，为什么 **两张虚表中的 `Advanced:: func1` 的地址不同**？

答案是，编译器进行了 **套壳**。

两张虚表中存储的 `Advanced:: func1` 的函数指针都不是`Advanced:: func1`真正的函数指针
编译器在`Advanced:: func1`的函数指针上又套了一层，即 虚表中存储、显示的函数指针只是一层外壳

编译器的这个处理，可以从多态调用的反汇编代码中分析出来：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220728110724739.png" alt="image-20220728110724739" style="zoom:80%;" />

> **于 `Base1`部分的 `Advanced:: func1` 的调用：**
>
> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/Advanced%20func1.gif" alt="Advanced func1" style="zoom:80%;" />
>
> 根据反汇编代码分析 `ptr1->func1` 的调用过程：
>
> 1. 首先是找到虚表中`func1`的函数指针`(0x00c31401)` 存储到寄存器 `eax` 中，`call eax`进行调用
> 2. 执行 `call eax` 跳转到 地址为 `00C31401` 的汇编代码处，此地址处的汇编指令为 `jmp 00C327A0`
> 3. 执行 `jmp 00C327A0` 之后 开始建立函数栈帧
>
> `00C327A0` 即为 `Advanced::func1` 的地址，因为跳转之后，进入函数开始建立函数栈帧
>
> 所以 虚表中存储的函数指针 `0x00c31401` 并不直接是  `Advanced::func1` 的地址 可以看作是一层壳子

> **于 `Base2`部分的 `Advanced:: func1` 的调用：**
>
> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/Base2%20Advanced%20func1.gif" alt="Base2 Advanced func1" style="zoom:80%;" />
>
> 观察动图 可以发现
>
> 调用 `Base2` 部分的 `Advanced:: func1`，比起调用 `Base1` 部分的，显然要更加复杂：
>
> 1. 首先同样是找到虚表中`func1`的函数指针`(0x00c31393)` 存储到寄存器 `eax` 中，`call eax`进行调用
>
> 2. 执行 `call eax` 跳转到 地址为 `00C31393` 的汇编代码处，但是此地址处的汇编指令为 `jmp 00C32820`，很明显**并不是 `00C327A0`** ，即 `Advanced::func1` 真正的地址
>
> 3. 跳转至 地址为 `00C32820` 的汇编代码处，发现 还有两个指令：
>
>     `sub ecx,8` 和 `jmp 00c31401` 
>
> 4. 执行了 `jmp 00c31401` 之后，再跳转至了 `jmp 00C327A0` 指令处
>
> 5. 执行  `jmp 00C327A0` 进入 `Advanced::func1` 开始建立函数栈帧
>
> 可以看到，虽然 `ptr2->func1();` **最后执行的也是  `jmp 00C327A0`**，但是其中间包含的**过程更多**

下面是两次调用 汇编代码简略的执行过程的对比：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220728142521678.png" alt="image-20220728142521678" style="zoom:80%;" />

可以看到，调用`Base1`部分的`func1`，是通过`Base1`虚表中的壳子 **直接跳转**到 真正的函数指针，然后建立栈帧

而 调用`Base2`部分的`func1`，则是通过`Base2`部分虚表中的壳子，**找到`Base1`虚表中的壳子**，**然后跳转** 到 真正的函数指针，再建立栈帧的

两种调用明明**调用的是同一个函数，为什么会产生这种差异**？

原因是：

归根结底，子类的`func1`是重写的父类的虚函数，即 此虚函数并不属于父类，而是属于子类的。所以在调用时，需要知道 子类对象的地址，再由此地址找到虚函数指针 进行对函数的调用。
而由于 `Base1` 是子类继承的第一个父类，所以子类对象的地址就是 `ptr1`指向的地址，所以可以直接 找到虚函数指针进行调用
但是，`Base2` 是子类的第二个父类，所以`ptr2`指向的地址与子类对象的地址相隔了一个 `Base1`的大小，所以才会有此指令：
`sub ecx, 8` 此指令就是去**找子类对象地址**的，`8` 即为 `Base1`的大小
找到子类对象地址之后，再像 `ptr1->func1` 那样 去找虚函数真正的指针 进而调用函数

> 当 `Base1` 大小改变时，`sub` 指令的偏移值就会改变：
>
> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220728154501678.png" alt="image-20220728154501678" style="zoom:80%;" />


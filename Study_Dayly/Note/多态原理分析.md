上一篇文章 详细介绍了什么是多态 和 多态的使用等方面的问题。但是却留下了一个最大的疑问

***编译器是怎么实现多态调用的？***

本篇文章的内容 就是分析多态实现原理的。

# 多态实现原理

## 虚函数表

在 介绍菱形虚拟继承的时候，介绍了一张表：**虚基表**，此表内存储的是数据的相对偏移量。是在菱形虚拟继承中存在的。

而上一篇文章介绍了多态，介绍了一种函数 `virtual 虚函数` 

一个类中存在虚函数，那么此类就会多出一个指向另一个表的指针，此指针叫 ***虚表指针***，此表叫 ***虚函数表，也称虚表***

怎么证明，存在虚函数的类会有一个虚表指针呢？

下面有一道面试题：

> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726134930627.png" alt="image-20220726134930627" style="zoom:80%;" />
>
> 上述类，**`sizeof(Base)`** 是多少？
>
> 按照类和对象的基础知识，**类成员函数不在类中 不占类空间，所以只计算 成员变量的大小，最总结果为 4**
>
> 但是实际查看会发现：
> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726135319978.png" alt="image-20220726135319978" style="zoom:80%;" />
>
> **Base 类的大小为 8(32位环境)**
>
> 这是为什么？查看Base 类对象内容：
>
> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726135849223.png" alt="image-20220726135849223" style="zoom:80%;" />
>
> 可以看到，除成员变量 _b 之外，还存在一个指针 指向了一张表，并且 **这个指针处于类对象的开头位置**
>
> 这个指针就是 **虚表指针**，指向的表就是**虚表**

虚表是干什么的？仔细观察虚表的内容，可以看出，**虚表内存储的是 类中所以虚函数的指针**，但是 在介绍类和对象的文章中就提到过，成员函数都是一起放在一个公共代码段的，所以其实 **虚函数并不是另外存储到了虚表中**

也就是说 虚表指针指向的**虚表 其实只是集合了 虚函数的指针，而不是存储了虚函数**，这些**虚函数还是与普通的成员函数一起存放在一个公共代码段**

也就是说，虚表指针 指向了一个 **存放有虚函数指针的地址** 
(虚表指针是一个二级指针，`**虚表指针` 可以直接取到虚表中的第一个虚函数)

---

**拥有虚函数的类存在虚表指针，指向虚表，虚表内容是 虚函数指针**

如果 继承体系中 父子类虚函数构成了重写，子类虚表的内容会是什么呢？

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726142249999.png" alt="image-20220726142249999" style="zoom:80%;" />

对比子类和父类对象的内容：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726142135476.png" alt="image-20220726142135476" style="zoom:80%;" />

可以看到，子类对象中继承于父类的那一部分也有一个虚表指针

但是因为重写了父类虚函数，所以虚表内的虚函数指针 是被重写之后的虚函数的指针
并且，**没有重写的虚函数与父类中的相同**，所以 子类中的虚表也可以看作是 **复制父类的虚表然后覆盖了被重写的函数** ,但是并不是真的复制+覆盖

---

子类对象 虚表的内容与父类对象相比较，重写的虚函数覆盖了原虚函数

那么还有一个问题：**子类对象自己的虚函数指针 会存放在哪里呢？**

举个例子：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726144150670.png" alt="image-20220726144150670" style="zoom:80%;" />

使用上面的子类 实例化对象并查看对象的内容：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726144411368.png" alt="image-20220726144411368" style="zoom:80%;" />

在VS的监视窗口中，子类对象，**既没有新建一个虚表存放只属于自己的虚函数的指针，原虚表中也没有显示只属于自己的虚函数指针**

子类中 **只属于自己的虚函数的指针到底存放在了哪里** ？

监视窗口中没有显示，但是在介绍继承的时候说过，VS的监视窗口是经过软件优化过后的，会不会只是监视窗口没有显示，但 只属于自己的虚函数指针 其实也在原续编中存储呢？ 

监视窗口可以看到虚表的地址，由此就可以从内存窗口中查看到地址存储的内容：
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726145241845.png" alt="image-20220726145241845" style="zoom:80%;" />

可以看到，需表中确实存储了 虚函数指针，但是**第三个指针不能确定是否 是只属于子类的虚函数的指针**，需要验证

***怎么验证？***

**可以取出虚表中的指针，然后调用指针，如果能调用 且 执行结果符合函数，就说明是 子类虚函数指针**

32位环境下，对象的头四个字节即为虚表指针，**怎么取头四个字节？**

> 虚函数的返回值类型为 void，参数为空，所以 函数指针类型为 `void(* )()`
>
> 将 函数指针类型 typedef 一下：`typedef void(*VFTPTR )()` 
> `VFTPTR` 即为新名字，函数指针的特性
>
> 虚表指针是一个 指向函数地址的指针，所以 **`VFTPTR*` 即为函数指针的类型**
>
> 所以，取对象的地址，再将其 强转为 `int*` ，再解引用，即为对象的头4个字节的值，也就是虚表指针的地址
> 再将其强转为 `VFTPTR*`，再赋给 `VFTPTR*`类型的变量，此变量就是虚表指针：
>
> **`VFTPTR* vTable = (VFTPTR*)(*(int*)&dav);`**
>
> 然后将 虚表指针传入此函数中：
>
> ```cpp
> void PrintVTable(VFTPTR vTable[])
> {	// 虚表指针地址是一个二维数组，所以形参可以为 VFTPTR 类型的数组
> 	// 依次取虚表中的虚函数指针打印并调用。调用就可以看出存的是哪个函数
> 	cout << " 虚表地址>" << vTable << endl;
> 	for (int i = 0; vTable[i] != nullptr; ++i)
> 	{
> 		printf(" 第%d个虚函数地址 :0X%x,->", i, vTable[i]);
> 		VFTPTR f = vTable[i]; 		// 取函数指针
> 		f(); 						// 函数指针调用函数
> 	}
> 	cout << endl;
> }
> ```
>
> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726152135478.png" alt="image-20220726152135478" style="zoom:80%;" />
>
> 继续调用函数：
>
> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726152400059.png" alt="image-20220726152400059" style="zoom:80%;" />
>
> 可以看到 函数指针调用函数，**第三个函数指针的执行结果确实与 子类自己的虚函数执行结果相同**
>
> 由此可以证明 **原虚函数表中确实存储了 属于子类自己的虚函数的指针，但是 VS的监视窗口中没有显示**
>
> > 个人感觉这是一个BUG

所以，其实 子类对象中 **无论是自己的虚函数 还是从父类中继承过来的虚函数**，无论重写与否，**其函数地址都存放在同一个虚函数表中**

总结，**虚函数表** 是存放类虚函数指针的一个表，此表不直接存储在对象中
而是在对象中存储一个指向 此表的指针，即 **虚表指针**

虚函数表的内容，会 **根据是否构成重写而发生变化**，这一变化是为多态的实现提供条件的

## 多态原理

分析了半天的虚函数表，说虚函数表是为多态的实现提供条件的，那么**多态究竟是怎么实现的？**

在上一篇文章中介绍过，多态需要满足两个条件：

1. 必须是**父类的指针** 或 **父类的引用** 来调用 ***虚函数***
2. 被调用的函数必须是 ***虚函数***，并且 此 ***虚函数*** 必须被 ***重写***

需要第二个条件的原由，其实在上面分析虚函数表时，已经得到答案了

***只有父类的虚函数被重写时，子类的虚函数表内 存储的才是 重写之后 的虚函数指针***
***否则，子类的虚函数表内 存储的依旧是 父类未被重写 的虚函数指针***

问题还剩一个，**为什么多态调用需要满足 父类指针或父类引用 调用虚函数？**

---

还是在C++继承的分析文章中，介绍过 **子类对象赋值给父类对象会发生切割**

并且延伸出

1. **子类对象的地址 可以切割给 父类指针**；
2. **子类对象 可以直接切割给 父类引用**

在多态的实现中，这两个性质 十分的重要：

以 买票的多态为例：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726185017441.png" alt="image-20220726185017441" style="zoom:80%;" />

当使用父类指针或父类引用接收子类的地址或对象时：

![image-20220726191641257](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726191641257.png)

可以发现：对象 `stu1`  和 `eld1` 的虚表内存储的都是 **重写后的虚函数的指针**
并且，父类指针 `ptrPer` 指向的就是 `stu1 的父类部分`；父类引用 `quoPer` 就是 `eld1父类部分的别名`

这样就可以赋予 父类指针 或 父类引用 不同的对象，来多态调用虚函数：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726192409169.png" alt="image-20220726192409169" style="zoom:80%;" />

但这只是满足了多态调用的两个条件。**编译器是如何选择多态调用还是普通调用的？**

用以下类 举个例子：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726231928693.png" alt="image-20220726231928693" style="zoom:80%;" />

`Advanced类`中的 `Func1` 重写了` Base类`中的 `Func1`，此时：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726232434061.png" alt="image-20220726232434061" style="zoom:80%;" />

由于 `ptrBas` 只是 `Advanced对象`中的**`Base`部分的指针**，所以 它指向的内容并**没有 `Advanced`类中的`Func2`**
所以 执行`ptrBas->Func2()` 时，默认会**普通调用 `Base`类中的`Func2()`**

不同的是，`Func1` 在`Advanced类`中重写了，并且 其函数指针被存入了虚表中。但 其实`Base类`中也是有`Func1` 函数的，**为什么 调用时去虚表中找重写后的函数指针并调用，而不是普通调用`Base`中的`Func1`？**

其实没有具体的为什么。

为实现多态，C++编译器设计的就是：
**当调用函数满足多态两个条件时，编译器不会在 编译时 就根据类中的函数确认函数调用地址，而是在运行时 查找虚表 进而确认调用函数的地址**

这是C++编译器 **为了实现多态而设定的一种机制**，机制是固定且明确的：**函数调用满足多态的两个条件**

当满足条件时，编译器就不在编译时确定函数调用的地址，而是在运行时查表确定

---

### 如何证明，多态调用函数是在运行时才确定函数地址的，而不是在编译时？

VS环境下证明的方法有一个，那就是 **查看反汇编代码** (此汇编是一个动作而不是语言)

依旧按照上面例子的操作，查看其反汇编代码：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220726234452222.png" alt="image-20220726234452222" style="zoom:80%;" />

首先可以非常明显的看到，多态调用 与 普通调用的反汇编代码的步骤是不一样的

尝试大致分析一下，两种调用方式 反汇编的意思：

> `dword` 为 4 字节

>  多态调用：
> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220727000215510.png" alt="image-20220727000215510" style="zoom:80%;" />
>
> 虽然具体意思不明确，但是大概意思还是可以看出来的
> 其实就是在**使用各种寄存器，找虚表，查虚表，然后找到函数地址了再call**
>
> 也就是说，程序再运行时 才去找函数地址了，能够说明 **多态调用函数，是在程序运行时才通过查表来确定函数地址的**

> 普通调用：
>
> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220727000717413.png" alt="image-20220727000717413" style="zoom:80%;" />
>
> 普通调用，直接就call了函数地址，也就是说运行时就已经知道了需要调用的函数的地址
>
> 所以 **普通调用是编译时就确定了函数的地址**

---

### 问题：为什么不能是 父类对象？

首先要先理解：

把子类对象 或 子类对象的地址 赋值给 父类引用 或 父类指针
并**不是创建了一个全新的父类对象**。而是由 父类指针指向子类对象的父类部分 或 直接给子类对象的父类部分去了别名。**本质上还是在子类对象上操作**的

但是 如果让 父类对象也可以实现多态
那么就需要 在子类对象给父类对象赋值的时候，将子类对象虚表内的 仅子类拥有的 已经重写后的虚函数指针 也赋值给父类对象。

这就导致了 **一个普通的父类对象 却 拥有了其他类的虚函数指针，合理吗？**

很明显是不合理的

如果一个普通的父类对象虚表内存储的是其子类对象的虚函数指针，那么自己的虚函数指针应该存储在哪里？

所以，不能让父类对象也实现多态，会错误、会混乱

# 单继承和多继承关系的虚函数表




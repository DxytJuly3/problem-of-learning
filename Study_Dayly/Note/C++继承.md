在首次接触，类与对象的时候就已经介绍过

C++ 是一种面向对象的编程语言，而面向对象有三大特性：封装、继承、多态(三大特性 而不是 只有三个特性)

在 类和对象中，就已经介绍过什么是封装特性，在本篇文章开始之前 再来说一下 我个人理解的封装特性

> 面向对象的语言中，面向对象的封装特性是什么？
>
> 在学习C++ 之前，先学习了 C语言，在接触了 C++ 的类之后，可以明显感觉到面向对象和面向过程的某些方面的区别
>
> 就拿对某种数据结构的模拟实现而言，比如 queue 队列：
>
> 1. 使用C语言实现队列，会发现 队列的结构 与 各种操作队列的功能：入队列、出队列、取队列的头等，是分离的。并且，C语言中实现队列 并没有对队列的数据等加以限制，这就表示 每一个使用者都可以直接操作数据而不是通过数据结构提供的接口等。
>     但是 C++ 中无论是模拟实现 队列，还是 库中提供的 queue，容器的结构 与 数据的操作接口是整体在一个类中的，并且，还可以指定 类中的内容用 访问限定符限制类外内容对对象内容的访问。这是C语言无法做到的。通过访问限定符 合适地对 类成员进行限制，使操作者能够更加 安全、规范的操作、整理、修改数据。进而可以禁止操作者对数据的非法行为等
> 2. 不仅仅是 整合 和 访问限制，封装更好地隐藏了 容器结构的底层。在我看来封装最好的诠释之一就是STL容器中的 迭代器设计，即之前介绍的 iterator 和 reverse_iterstor 的结构、实现及其部分细节，都是为了对容器结构的隐藏和保护。倘若没有 iterator 即迭代器的的设计，那么使用者想要访问、修改数据 大概率只能通过直接操作底层来操作数据，迭代器 杜绝了这种情况。可以不让操作者与底层直接建立联系，进而可以保护底层
> 3. 而且，封装可以更加简单快捷的编写代码，比如 库中实现 stack、queue、priority_queue 使用的一种适配器的模式，将已经实现过的容器进行封装整理，在以后实现其他容器时 加以使用，能更加简单的得到想要的结果。
> 4. 在互联网中，在这个信息时代，最重要的资源 就是数据。封装 某中程度上提升了 数据的安全，将底层、细节等对大部分人隐藏起来，只提供最简单、便捷的接口，从而可以降低对数据操作的门槛，但也进行了对底层访问的限制。总的来说，封装一种可以让数据更安全、让编写者更方便快捷、让使用者更简单易懂的一种手段、方法

而，本篇文章的主要内容 是面向对象的三大特性之一的 继承 在C++ 中的体现

# 继承

C++中，继承是什么？

在 C++ 中继承主要表现形式是：**类的复用**。

在此之前，其实已经接触过了 关于复用的操作——关于函数的复用。
在此之后，复用就不再仅仅局限于函数，还有类的复用，不过类的复用一般被称作 **继承**

## 继承的概念

**继承是一种机制**，是面向对象程序设计 **使代码可以复用的最重要的手段**

它允许 **在保持原有类特性的基础上进行扩展，增加功能，从而产生新的类**

继承呈现了面向对象程序设计的层次结构

> 继承一般用于什么？
>
> 举一个简单的例子：
>
> 比如在学校这种存在多种职务的场所：
>
> 学校：校长、老师、学生等
>
> 学校的每种职务，其实都具有 人 的共同的某些属性——姓名、性别、年龄、电话、住址…… 
> 而不同的职务又有各自的独有的属性：老师—评分—工号，学生—学分—学号 等
>
> 所以，在定义 老师、学生类之前，可以先定义一个成员包括姓名、性别、年龄、电话等的 人 类，然后再复用这个 人 类 定义老师、学生的类
>
> 这样可以有效减少代码量，方便、快捷	

## 继承的定义

那么 类的继承 是怎么样定义的呢？

就以 学校的老师和学生为例，首先需要定义一个 人 类：

![image-20220719014159953](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220719014159953.png)

在介绍类和对象的时候 提到过，类的访问限定符有三个：public、protected、private, 分别表示公共、保护、私有

且当时提了一句，暂且将 protected 和 private 修饰的成员看作相同的

而在继承中，它们就不一样了

类的访问限定符是他们三个，而类的继承方式 也是他们三个：`public`、`protected`、`private`

类的继承究竟是如何定义的呢？

以 定义学生类继承上面那个类为例：
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220720145047208.png" alt="image-20220720145047208" style="zoom:80%;" />

图中所示即为继承定义的格式，简单的表示即为：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220720152842901.png" alt="image-20220720152842901" style="zoom:80%;" />

以上面的继承格式为例：**Student 被称为，子类 或 派生类；public 被称为 继承方式；Person 被称为 父类 或 基类**

### 继承方式与基类成员访问限定符的关系

继承方式有三种，public 公有继承，protected 保护继承，private 私有继承

访问限定符也有三种，public 共有访问，protected 保护访问，private 私有访问

那么这 三者 与 三者之间有什么关系呢？

| 类成员限定、继承方式👉<br />👇 | public 继承                 | protected 继承              | private 继承              |
| ---------------------------- | --------------------------- | --------------------------- | ------------------------- |
| 父类的public成员             | 可看作 子类的public成员     | 可看作 子类的protected 成员 | 可看作 子类的private 成员 |
| 父类的protected 成员         | 可看作 子类的protected 成员 | 可看作 子类的protected 成员 | 可看作 子类的private 成员 |
| 父类的private成 员           | 在子类中不可见              | 在子类中不可见              | 在子类中不可 见           |

表中表示的就是 继承方式 与 基类成员访问限定符 的关系，分析一下就是：

1. 父类的 private成员 在子类中**无论以什么方式继承都是不可见的**。

    不可见 是指**父类的private成员 已经被继承到了子类对象中**，但是语法上限制 **子类对象不管在类里面还是类外都不能去访问它**

    做个父类的 公有成员和私有成员 对比更能展现 父类私有成员的特点：

    > 公有成员：
    >
    > ![image-20220720233231294](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220720233231294.png)
    >
    > 私有成员：
    >
    > ![image-20220720233337801](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220720233337801.png)
    >
    > ![image-20220720233347610](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220720233347610.png)
    >
    > 即，父类的私有成员，**虽然对子类不可见、不可访问，但是 是实实在在继承下来了的**
    >
    > 当**父类有私有成员时子类的大小 与 父类没有私有成员时子类的大小 相同**

2. 父类private成员在子类中是不能被访问，如果**父类成员不想在类外直接被访问，但需要在派生类中能访问，就定义为protected**

    在 刚学习类和对象时，说 暂时将 protected 和 private 看为作用一样的访问限定符，但是 到了继承这里，他们的作用就不一样了。

    **父类的 protected 保护成员，在子类内 是可访问的，但是在子类外 是不可访问的**
    *类似 没有继承关系的 private 私有成员*

    > 用一张图可以清晰的表现出来
    >
    > ![image-20220720234912257](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220720234912257.png)
    >
    > **父类的保护成员，被子类继承之后，在子类内可以访问，但是在子类外不能访问**

3. 仔细分析 父、子类限定成员关系与继承方式关系 的表格，可以发现

    除 父类的私有成员，**无论哪种继承方式在子类中都不可见 之外**

    继承方式 与 父类成员种类，在子类中的访问限定 是 **两者取小** 的方式，比如：
    父类中的 **protected成员，即使是 public继承 给子类，在子类中依旧看作 protected成员**

    而 父类中的 **public成员，若是 protected继承给 子类，在子类中则看作 protected成员**

    父类中的 **public成员、protected成员，若是 private继承给 子类，在子类中就看作 private成员**

4. 而在实际运用中一般都使用 public继承

    几乎很少使用 protected / private继承，也不提倡使用 protected/private继承，因为 protected/private继承下来的成员都只能在派生类的类里面使用，实际中扩展维护性不强  

## 父类 与 子类对象的赋值

当两个类有继承关系的时候，**子类对象 是可以 赋值给父类对象、父类指针、父类引用** 的，这是 C++ 的语法设计，即 **语法默认支持的，中间没有任何的 类似类型转换的转换**

但是，这个赋值 **并不是将 子类对象的全部 赋值给父类对象**，父类对象也不可能接收子类对象的全部；
**而是 将子类对象中 从父类对象继承过来的部分 赋值给父类对象**，这个过程 被形象的称为 **切片、切割**

举个例子：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220721003947954.png" alt="image-20220721003947954" style="zoom:80%;" />

可以看到，`stu` 切割给 `per`，使 `per` 原数据改变，即说明 **子类对象 可切割给 父类对象**

而 对于 父类指针 和 父类引用：

![stu_pper_perx](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/stu_pper_perx.gif)

可以看到 **子类对象的地址 可以 切割给父类指针**；**子类对象 可以直接切割给 父类引用**

> 子类对象 可以切割给 父类对象，这个父类对象是一个独立的、新的父类对象
>
> 而 父类指针 和 父类引用 就没有那么简单了，
>
> 这两个，一个是指针 应该指向父类对象的地址，另一个是引用  应该是一个父类对象的别名
> 而 由子类对象赋值，会发生什么呢？
>
> ![image-20220721005500893](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220721005500893.png)
>
> 说明，其实 **子类对象的地址 切割给父类指针**；**子类对象 切割给 父类引用** 
> 就表示 **此父类指针是直接指向 子类中从父类继承部分的，此父类引用 是子类对象中 从父类继承部分的别名**
>
> 也就表示了，**修改 父类指针 和 父类引用，是直接修改在 子类对象上**的:
> ![image-20220721010127135](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220721010127135.png)
>
> 但是要注意，**此操作 仅限于 子类对象被切割给的 父类指针 和 父类引用上**

不过，虽然 *子类对象 可以 赋值给父类对象* ，但是 **父类对象 不能 赋值给 子类对象**

![image-20220721010726568](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220721010726568.png)

>  **父类指针 和 父类引用 是通过强制类型转换  可以赋值给 子类指针 和 子类引用的** ，但是 这个操作与 **多态** 有关，就暂不赘述
>
> 注意：**子类对象 赋值给父类对象、父类指针、父类引用** ，这是 **语法默认支持的，中间没有任何的 类似类型转换的转换**

综上所述，父类 与 子类对象的赋值转换 可以这样用图表示：

![子类对象 至 父类](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220721013157021.png)

## 继承作用域相关

拥有继承关系的类，子类内的作用域 也有限制：

1. 子类内，继承父类的部分 与 子类自己的部分 是 **两个独立的作用域**

既然是两个独立的作用域，就不得不考虑一个问题：两个独立的作用域 按理来说是可以存在 同名变量或同名函数的，那么**子类内可不可以存在 与 父类内 同名的变量 或 同名的函数(同名成员)呢？**

答案是 **可以**

2. 子类和父类中可以存在同名成员，但是**子类成员 将屏蔽 父类对同名成员的直接访问**，这种情况叫**隐藏**，即 子类中的成员 将 父类中的同名成员隐藏了起来，这种情况也叫 **重定义**。

    > 什么是 **屏蔽父类对同名成员的直接访问**？
    >
    > 举个栗子：
    >
    > ![image-20220721014511184](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220721014511184.png)
    >
    > 当这样的 子类实例化出来的对象，直接访问 `_age` , 会访问哪个 `_age` 呢？是 继承父类部分中的 还是 自己的？
    >
    > 答案 很明显：
    >
    > <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220721014742874.png" alt="image-20220721014742874" style="zoom:80%;" />
    >
    > 直接访问 `_age` 会访问 `stu 自己的 _age` 而不是继承父类的 `_age`
    >
    > 其实这就是  **子类成员 屏蔽父类对同名成员的直接访问**，就是 子类成员将 **父类同名成员隐藏了起来**

    虽然，父类同名成员被隐藏了起来，但是 还是**可以通过 指定类域 来实现对父类同名成员的访问**的：

    <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220721015345802.png" alt="image-20220721015345802" style="zoom:80%;" />

3. 成员函数也可以构成隐藏，且 **仅函数名相同 就会构成隐藏**

4. **在实际中在继承体系里面最好不要定义同名的成员* **

## 子类的默认成员函数

 

![Blog_SXDTXHLB_cover](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/Blog_SXDTXHLB_cover.png)

---

# 引言

在 `数据结构与算法：单链表篇` 的时候，已经介绍了 `链表` 的多种结构 `(具体内容可以去单链表的那篇去看一下，这里不再赘述)`

> [🌈【神秘海域】[动图] 掌握 单链表 只需要这篇文章~ 「超详细」](https://d-xyt.blog.csdn.net/article/details/124262999)

而且呢，也在单链表篇提到，链表会详细介绍两种结构 ：

1. `不带头节点的单向非循环链表`
2. **`带 头节点的双向循环链表`**

本篇文章的的具体内容就是 **`带 头结点的双向循环链表`** 接口的实现



**`带 头结点的双向循环链表(以下简称带头双向循环链表)`**~~`(好像也没多简)`~~  在结构上是 `最复杂` 的一种链表结构，但是 在使用、实现时，其实是 `最方便、最简单` 的一种链表结构

下面就就来详细介绍一下 **`带头双向循环链表 节点结构及接口`** 的实现：



---

# 带头双向循环链表

`带头双向循环链表的结构` 示意图是这样的：

![image-20220503180047664](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220503180047664.png)

## 节点结构

观察其结构，实现过单链表之后，**`带头双向循环链表的节点`**可以直接写出来了：

```c
typedef int ListDataType;
typedef struct ListNode
{
	ListDataType val;
	struct ListNode *prev;
	struct ListNode *next;
}ListNode;
```

一个数据类型变量 `存放数据` ，一个结点指针 `存放下一节点地址`，第二个结点指针 `存放前一节点地址`

## 接口及实现

**`带头双向循环链表`** 功能接口 与 `单链表` 的功能接口 基本一致：

1. `ListInit`  链表初始化
2. `BuyListNode`  创建新节点
3. `ListPushBack`  链表尾插
4. `ListPopBack`  链表尾删
5. `ListPushFront`  链表头插
6. `ListPopFront`  链表头删
7. `ListFind`  查找节点
8. `ListInsert`  链表 `pos` 位置插入
9. `ListErase`  链表 `pos` 位置删除
10. `ListPrint`  链表打印
11. `ListDestroy`  链表销毁

### 链表尾插 ListPushBack

这一次先不实现 `链表的初始化接口`， 直接实现一个尾插的接口：

不过在实现尾插之前，需要先实现 `BuyListNode 创建新节点` 接口：

> ```c
> ListNode* BuyListNode(ListDataType x)
> {
> 	ListNode *newNode = (ListNode*)malloc(sizeof(ListNode));
> 	if (newNode == NULL)
> 	{
> 		printf("BuyListNode fail!\n");
> 		exit(-1);
> 	}
> 	// 节点赋值
> 	newNode->val = x;
> 	newNode->prev = NULL;
> 	newNode->next = NULL;
> 
> 	return newNode;
> }
> ```

**`带头双向循环链表`** 的尾插，不需要像 `单链表` 那样找尾，因为 头节点的 `prev` 节点就是链表的尾节点

所以可以在此基础上 直接进行尾插：

#### 尾插动图

代码实现即为：

```c
// 带头双向循环链表 尾插
void ListPushBack(ListNode *phead, ListDataType x)
{
	assert(phead);

	ListNode *newNode = BuyListNode(x);
	ListNode *tail = phead->prev;				// 记录 头结点的prev节点

	newNode->prev = tail;
	tail->next = newNode;

	newNode->next = phead;
	phead->prev = newNode;
}
```

这就是 对一个有数据的链表尾插操作的接口 实现



### 链表初始化 ListInit

`不带头的单链表` 不需要初始化，因为如果此结构的链表为空，直接定义结点指针为空就可以了。

但是 **`带头双向循环链表`** 是需要初始化的，不仅仅是因为 此结构存在一个头节点。

那么 **`带头双向循环链表`** 需要怎么初始化呢？

1. 首先一定是，需要一个头节点
2. 其次，虽然只有一个头节点，但既然是 **`带头双向循环链表`** 那么 只有一个头节点也是因该是一个 `循环链表`

所以，初始化应该有这两个功能：

```c
void ListInit(ListNode **pphead)
{
	assert(pphead);

	*pphead = BuyListNode(0);
	(*pphead)->next = *pphead;
	(*pphead)->prev = *pphead;
}
```

这个初始化接口，实现了 `定义一个头节点`  并 `将其设置为循环` 

>  实现的代码中，需要注意的是：
>
> 1. 因为需要改变参数原值，所以需要传 `二级指针`
> 2. 头节点的 `数据变量` 最好不要存放任何有用数据，所以可以随意传值
> 3. 由于 `操作符优先级` 的问题，`*pphead` 需要用 `()` 括起来

但是这样的初始化接口需要传入二级指针，如果操作不当，可能会操作不必要的麻烦

所以 **`带头双向循环链表`** 的初始化接口 还有另外一种直接 `不需要传参` 的写法：

```c
ListNode* ListInit()
{
	ListNode *phead = BuyListNode(0);
	phead->next = phead;
	phead->prev = phead;
    
    return phead;
}
```

直接在函数内部 定义一个头节点，然后作为返回值，返回到调用的位置 用一个变量接收。

这两种方法没有优劣之分，看使用习惯。`(以下均使用第二种)`



---

初始化之后的链表，除了头节点之外是没有其他数据节点的。

那么在没有其他数据节点的情况下，上面所写的尾插接口 还能成功实现功能吗？

调试分析：

![image-20220503220100159](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220503220100159.png)

![image-20220503224018491](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220503224018491.png)

光标进入 `尾插接口`：

![image-20220503220602287](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220503220602287.png)

光标继续移动，将 `tail` 与 `newNode` 连接起来

![image-20220503221543363](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220503221543363.png)

![image-20220503230829976](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220503230829976.png)

再将 `newNode` 与 `phead` 连接起来：

![image-20220503221910810](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220503221910810.png)

![image-20220503231509032](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220503231509032.png)
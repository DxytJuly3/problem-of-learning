在Linux操作系统中, `文件描述符`是一个至关重要的概念.

理解了文件描述符, 其实就可以相当于理解了`Linux系统的关于内存文件系统的整个大致框架和逻辑`

但是在介绍文件描述符之前, Linux关于文件还存在许多 概念和文件操作 的知识需要介绍一下, 就当作是为解释文件描述符所做的准备吧

# 文件的相关概念

在初次介绍Linux文件权限的时候, 对于文件 提到过一个概念：

## 文件

在介绍Linux操作系统的文件权限时, 提到过这个概念：`文件=文件内容+文件属性`

并且问了一个问题也做出了解答: `当一个文件的文件内容为空时, 此文件是否占用磁盘空间？`

这个答案是肯定的, 即使`文件的内容为空, 其实此文件也是占用磁盘空间的`, 因为文件并不只有内容, 文件还有属性

就像下面这个文件:

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230315171754060.png" alt="image-20230315171754060" style="zoom:80%;" />

即使此文件没有所谓的文件内容, 但还存在文件属性：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230315172458395.png" alt="image-20230315172458395" style="zoom:80%;" />

使用 stat 命令可以直接查看文件的部分属性, 既然文件在磁盘中存在属性, 那么其在磁盘中就不会不占用空间

## 文件操作

既然 `文件=文件内容+文件属性`

那么文件操作实际上就是什么呢？

没错, `文件操作 = 文件内容操作 + 文件属性操作`

并且, 在进行文件内容的操作时, 往往会同时对文件的属性进行操作. 因为操作文件的内容势必需要打开文件、访问文件, 此时文件的访问时间也会被修改, 也就对文件的属性进行了操作. 

对文件属性的操作并不总是需要打开文件的. 在介绍Linux文件权限的时候, 我们可以直接使用 chmod命令 来修改不同用户对文件的权限

但是对于文件内容的操作, 其实`总是需要先打开文件`的.

那么我们常说的打开文件, 究竟是什么意思？

其实`打开文件的实际操作, 就是将文件的内容、文件的属性加载到内存中`, 当文件的内容、文件的属性被加载到内存中, 我们就称此文件被打开, 被打开的文件也被称为`内存文件`, 与之对应的, 没有被打开的文件, 可以被称之为磁盘文件

## 如何文件操作

在没有了解过操作系统的进程之前, 或许可以说文件操作是操作系统进行的

但是在了解过进程之后, 我们应该理解到 `文件的操作其实是由进程进行`的

为什么？

就拿c语言的文件操作来说, C语言提供了一些文件操作的接口：`fopen() fclose() fread() fwrite()……`

这些接口可以在我们编写C语言代码程序的时候使用, 当使用这些接口的代码被编译为可执行程序之后, 运行此程序就可以针对文件进行操作

而运行起来的程序实际上是什么？程序被加载到内存中之后, 进程就被创建了, 所以实际上 对文件进行一系列操作的执行者, 其实是进程

## 简单C语言文件读写操作

博主其实已经写了一篇有关C语言文件操作的文章. 但还是需要在此文章中再简单复习一下

C语言想要操作文件, 首先就需要使用fopen() 打开文件, 

```c
FILE *fopen(const char *path, const char *mode)
```

fopen的第一个参数传入的是需要打开文件的路径, 第二个参数则是打开文件的权限和方式：

> 有表示读写权限的：
>
> | 字符串 |  权限  |                             说明                             |
> | :----: | :----: | :----------------------------------------------------------: |
> | `"r"`  | `只读` |     只允许读取，不允许写入。文件必须存在，否则打开失败。     |
> | `"w"`  | `写入` |  若文件不存在，则创建一个新文件；若文件存在，则清空文件内容  |
> | `"a"`  | `追加` | 若文件不存在，则创建一个新文件；若文件存在，则将写入的数据追加到文件的末尾 |
> | `"r+"` | `读写` |       既可以读取也可以写入。文件必须存在，否则打开失败       |
> | `"w+"` | `写入` | 既可以读取也可以写入。若文件不存在，则创建一个新文件；若文件存在，则清空文件内容 |
> | `"a+"` | `追加` | 既可以读取也可以写入。若文件不存在，则创建一个新文件；若文件存在，则将写入的数据追加到文件的末尾 |
>
> 还有表示读写方式的：
>
> | 字符串 |          说明          |
> | :----: | :--------------------: |
> | `"t"`  |  以文本文件方式读写。  |
> | `"b"`  | 以二进制文件方式读写。 |
>
> 但是我们简单的复习, 就只考虑以文本文件方式读写, 不考虑二进制的方式

若是打开文件并向文件中写入内容, 执行下面这段代码：

```c
#include <stdio.h>

int main() {
	FILE *pf = fopen("new_log.txt", "w+");

	fprintf(pf, "88888888888\n");

	fclose(pf);

	return 0;
}
```

### 文件创建位置

在编译执行之前, 先思考一个问题：上面这段代码使用fopen打开文件时, 并没有指定打开文件的具体路径, `在保证之前没有此文件的时候, 打开的文件会在那里创建？`

会是在程序文件所在路径吗？

当我们执行之后, 可以发现：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230315200421031.png" alt="image-20230315200421031" style="zoom:80%;" />

但是事实是这样的吗？

我们把生成的文件删除, 进入其他路径下执行~/myBlog/FileDescrip/newFile 可执行文件(即上述代码编译生成的可执行程序)：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230315201218411.png" alt="image-20230315201218411" style="zoom:80%;" />

由此可见, 在`使用fopen()打开没有指定路径的文件时, 进程会在其运行的当前路径创建文件, 而不是在可执行程序文件的所在路径`

这是在了解了Linux进程之后回过头来再看C语言的文件操作, 可以发现的新的细节

### w写入规则

然后关于读写权限：

当我们使用w相关权限来向文件中写入内容时：

我们第一此插入 5 行数据：

```c
#include <stdio.h>

int main() {
	FILE *pf = fopen("new_log.txt", "w+");
	
	int cnt = 5;
	while(cnt--) {
		fprintf(pf, "88888888888\n");
	}

	fclose(pf);

	return 0;
}
```

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230315201827732.png" alt="image-20230315201827732" style="zoom:80%;" />

第二次只写入一行数据：

```c
#include <stdio.h>

int main() {
	FILE *pf = fopen("new_log.txt", "w+");
	
	fprintf(pf, "88888888888\n");

	fclose(pf);

	return 0;
}
```

执行第二次的程序之后, 可以发现, 第一次写入的 5 行数据没有了：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230315202014885.png" alt="image-20230315202014885" style="zoom:80%;" />

这说明, `使用w向文件中写入数据会先将文件中的原内容清除`

### a写入规则

在读写权限中, 除了`r+` `w` `w+` 之外, 还存在另两种写入权限 `a` `a+`

`a` `a+` 打开文件时的规则与 `w` `w+` 相同, 即 没有文件时创建文件. 

但是写入数据的规则有所不同

`w` 和 `w+` 写入的规则是, 先清空文件中原有的数据, 而 `a` `a+` 则是在文件的末尾除追加数据：

再不删除上面的 new_log.txt 文件时, 执行下面这段代码：

```c
#include <stdio.h>

int main() {
	FILE *pf = fopen("new_log.txt", "a+");
	
	fprintf(pf, "222\n");

	fclose(pf);

	return 0;
}
```

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230315202646301.png" alt="image-20230315202646301" style="zoom:80%;" />

可以看到, 在文件的原数据中, 又追加了指定数据.

而提到追加数据, linux操作系统中存在一个命令行符号操作：`追加重定向 >>`, 是否与`a+` 有相同的作用？

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230315203333678.png" alt="image-20230315203333678" style="zoom:80%;" />

好像是相同的作用

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230315204242618.png" alt="image-20230315204242618" style="zoom:80%;" />

### 模拟实现cat命令

简单的复习了C语言文件读写的操作之后, 在结合在Linux中的C语言的相关的知识

我们其实可以模拟实现一个 cat 的命令：

```c
#include <stdio.h>

#define SIZE 1024

int main(int argc, char *argv[]) {
	if(argc != 2) {						// 执行程序时 之后没有跟随一个文件时
		printf("using: ./%s filename", argv[0]);
	}

	FILE *pf = fopen(argv[1], "r");		// 只读方式打开传入的文件
	
	char buffer[SIZE];
	while (fgets(buffer, sizeof(buffer), pf) != NULL) {			// 从打开的文件中读取文本写入到buffer数组中
		printf("%s", buffer);
	}

	return 0;
}
```

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230315205847970.png" alt="image-20230315205847970" style="zoom:80%;" />

## 系统级文件接口有关问题

1. 在Linux系统中, 我们向文件内写入数据, 本质上是否是向什么中写入数据？

	向文件写入数据, 本质上其实是`向磁盘中写入数据`, 因为文件没有打开时, 本质上还是在磁盘中存储的

2. 磁盘是硬件, 谁有资格向硬件中写入数据？

	只有作为软硬件的管理者`操作系统, 有资格向硬件中写入数据`

3. 那么我们在上层访问文件的操作, 是否可以绕开操作系统？

	上层访问文件的操作, `不可能绕开操作系统`, 访问文件本质上都是由操作系统操作的

4. 操作系统如何给上层用户提供访问文件的操作？

	操作系统可以给上层`提供系统调用`

5. 为什么C语言中没有见过也没有使用过系统调用？

	因为, C语言中的不管是文件操作, 还是某些流的操作, 都对系统调用进行了封装

	

6. 为什么语言要对系统调用进行封装？

	首先, 原生的系统调用接口的使用并不是很简单的, 使用成本有点高(与封装后的接口相比)

	其次, 原生的系统调用接口并不具备跨平台的功能, `不同平台相同的功能的系统调用接口是不同的`, Windows、Linux、MacOS等都是不同的, 所以语言需要`对不同的平台的系统调用接口进行封装, 进而使语言具备跨平台的功能`

7. 封装如何解决不能跨平台的问题？

	以C语言为例, C语言的fopen()操作 实际上可能是将所有支持的平台的关于打卡文件的系统调用接口穷举了一遍, 并结合条件编译 使fopen()实现了跨平台的功能

8. 为什么要学习系统级的文件相关接口？

	首先, 系统级的相关接口比起每种语言的接口来说, 一定更接近系统底层, 可以更加了解底层

	其次, 学习系统调用之后, 对于各种语言的相关封装接口也可以有更加透彻的理解


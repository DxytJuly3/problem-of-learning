# 一、运算符重载

C语言中，运算符(操作符) 是只能对 `内置类型数据或表达式` 进行操作的

而 C++ 中，引入了 `运算符重载`，使同类对象之间可以使用运算符，进而提高代码可读性
否则对象之间，一个简单的比较大小就得需要长代码实现. 如果需要多次比较，将十分痛苦

## 1.1 运算符重载定义

`运算符重载` 其实是一种具有`特殊函数名`的函数，其 `返回值类型` 与 `参数类型` 同一般函数一样
但是 运算符重载函数的函数名格式为：`operator运算符` 即，operator + 需要重载的运算符
则函数的原型格式就为：`返回值类型 operator运算符(参数列表)`

并且，运算符重载还需要严格遵守一些规则：

1. `不能创造新的运算符`：比如 通过`operator@` 想要赋予`@`一定的功能
2. `重载运算符必须至少有一个自定义类型的操作数` ：操作符必须要有操作数
3. `重载后的运算符不能改变原有含义`：不能将原来内置类型`+`的功能，重载之后改为 对象之间相减的功能
4. `.*` 、`::` 、`sizeof` 、`? :` 、`.` 以上5个运算符不能重载`(笔试、面试会考)`

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/%E4%B8%BE%E4%B8%AA%E6%A0%97%E5%AD%90.jpeg" alt="举个栗子" style="zoom:25%;" />

以 `日期类判断大于` 为例：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/date-202206231736.png" alt="date-202206231736" style="zoom:40%;" />

判断日期类大于，则函数定义就是这样的：

```cpp
bool operator>(const Date& d1, const Date& d2)	//比较大小不需要改变数值，所以const修饰，&可以节省资源
{
	// 日期比较大小需要遵循实际
    return (d1._year > d2._year
            || (d1._year == d2._year && d1._month > d2._month)
            || (d1._year == d2._year && d1._month == d2._month && d1._day > d2._day));
}
```

当然因为C++类有封装特性，所以 `运算符重载函数是可以定义在类内`的，不过与定义在类外有一定的区别：

5. 由于类内存在隐含的 `this指针`，所以参数要比类外少一个，参数要比运算符所需操作数少一个，且`默认 this指针 为第一个参数`
    `(这也是重载需要严格遵守的第五条规则)`

在类内定义操作符重载：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220623175907224.png" alt="image-20220623175907224" style="zoom: 67%;" />

---

操作符重载是一种函数，一般函数应该`传参使用`：
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220623180915807.png" alt="image-20220623180915807" style="zoom:67%;" />

但是，操作符这样用非常的反逻辑，所以其实`操作符正常逻辑`使用也是没有问题的
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220623181138027.png" alt="image-20220623181138027" style="zoom:67%;" />

> 重载后的操作符，可以按照 正常的逻辑 使用
> 但其实，编译器还是会把使用操作符的语句，自动转换成这样 `d1.operator>(d2)` 或 这样`operator>(d1,d2)`，不用手动操作

## 1.2 赋值运算符重载

赋值运算符重载函数 其实与 拷贝构造函数 类似

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/%E4%B8%BE%E4%B8%AA%E6%A0%97%E5%AD%90.jpeg" alt="举个栗子" style="zoom:25%;" />

日期类的赋值运算符重载，内容也非常的简单，但是`有一些需要非常注意的问题`：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220623182635689.png" alt="image-20220623182635689" style="zoom:67%;" />

赋值运算符重载，确实与拷贝构造函数相似，但是 `为什么赋值运算符重载函数，需要返回赋值后的结果`？

当然是因为，`内置类型的赋值运算符(=)`结果也是需要当作返回值返回的，因为需要实现连等(连续赋值)操作：
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220623183051717.png" alt="image-20220623183051717" style="zoom: 67%;" />
所以，`赋值操作的结果要作为返回值返回，以便下一次赋值使用`，所以，将 `*this` 作为返回值返回

> 返回值是 `Date&` 类型的，使用引用是因为可以节省资源
> 但是并不是任何时候都可以使用引用类型作为返回值类型，因为 函数内的局部变量出了作用域就销毁了，如果再用`&`只会造成错误
> 这里使用 `&`，是因为 `this指针` 没被销毁

---

其实，在介绍类的默认成员函数时，有提到`赋值重载函数也是 类的默认成员函数`

这也就意味着，`一个类，如果没有显式定义赋值重载函数，编译器也会自动生成一个赋值重载函数，赋值操作按字节拷贝完成`

也就是说，对于成员变量简单的类来说，其实大部分都不用手动实现 默认成员函数

但是对于成员变量稍微复杂一点的变量来说，默认成员函数都是要手动实现的

### 1.2.1 思考

思考 此语句调用 赋值重载函数 还是 拷贝构造函数(`d1`已存在)：

`Date D = d1; `

回答之前，先对比一下 赋值重载 和 拷贝构造 具体用于什么环境下：

1. 赋值重载：将一个对象的内容 赋值于 另一个对象
2. 拷贝构造：在对象实例化时，将一个对象的内容 初始化至 正在实例化的对象

这样一对比，其实就已经知道 `Date D = d1` 调用的是哪个函数了

这个语句调用的是 `拷贝构造函数`，因为这是`在对象实例化时，要进行的初始化`。编译器会分析出来并自动调用拷贝构造函数

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/operator=.gif" alt="operator=" style="zoom:80%;" />

可以看到， `Date d2 = d1;` 这个语句被执行时调用的是 `拷贝构造函数`；
而 `d2` 被实例化之后，再执行 `d2 = d1`，则调用 `赋值重载函数`.

## 1.3 日期类及运算符重载实现

上面已经对日期类实现了 大于与赋值运算符的重载

待实现的还有：`==`、`>=`、`!=`、`<`、`<=`、`+`、`-`、`+=`、`-=`、`++`、`--`等

下面就从 `==` 开始逐一实现

---

### ==
判断两对象是否相等非常的简单：
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220623224933470.png" alt="image-20220623224933470" style="zoom:50%;" />

其实，在实现了`>` 或 `<` 的重载 和 `==`的重载之后，其他的逻辑判断运算符，都可以直接复用 `>`和`==` 或 `<` 和 `==` 来实现

### >=、!=、<、<=：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/carbon(3).png" alt="carbon(3)" style="zoom:44%;" />

### +

对于日期类，实现 计算用运算符的重载，`需要存在一定的意义`

比如，两个日期相加 是没有什么实际意义的：`2002.1.1` + `2000.1.1` 有什么实际意义呢？

所以，日期类重载 `+` 一般实现的是，`日期 + 天数` 的功能

不过，日期的计算需要参考实际情况：
1、3、5、7、8、10、12月：`31天`；
4、6、9、11月：`30天`；
2月：`一般28天，闰年29天`

由于日期的多变，所以日期计算实现起来稍微复杂一点：

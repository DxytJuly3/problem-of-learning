进程地址空间的设计使进程拥有一块独立的空间, 为进程增添了独立性 和 安全性.

但是, 各种进程在操作系统中运行时, 总逃不了可能某些进程之间需要进行交流. 而此时, 进程地址空间的存在又好像成为了进程之间通信的一层阻隔.

# 进程通信

关于什么是进程通信的问题, 在操作系统中, 进程通信实际上就是 **`不同进程之间传输、交换数据`**

那么为什么进程之间要通信呢？为了进程之间不互相干扰, 不是已经用进程地址空间将进程独立了吗？

## 为什么要有进程通信

虽然进程拥有自己的虚拟地址空间, 但是也并不能阻止进程之间可能存在通信的需求

比如：

1. 进程之间数据传输：

	一个进程需要将自身的数据 发送到 另一个进程; 或者 一个进程 需要 另一个进程的数据

2. 进程需要共享资源：

	就像可能多个进程可以同时使用加载到内存中的动态库代码一样

3. 通知事件

	就比如, 在Linux中, 子进程运行终止 需要告诉父进程运行结果

4. 进程控制另一个进程：

	比如, 我们在使用程序调试代码的时候, 其实就是一个进程完全控制了另一个进程的执行, 让我们可以在进程运行时打上断点、执行下一个语句等

5. ……

这些都是进程通信的需求, 有需求那么就要提供方法.

## Linux进程通信方法

Linux为我们提供了三种进程间通信的方法：

1. `pipe 管道通信`

	管道通信相信许多人已经用过了, 在命令行中的标志就是: `|`: 

	![image-20230324112501490](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230324112501490.png)

	管道通信一般用来进程之间传输数据.

	比如在上面的例子中, 我们将ps 进程执行的数据通过管道传输给了 grep, 才能筛选出指定的内容

	管道通信又分为：`匿名管道` 和 `命名管道`

	管道通信是本片文章的主要内容

2. System V 进程通信

	System V 是一套进程通信的标准, 可以为操作系统提供进程通信的接口, 非本篇文章的主要内容

3. POSIX 进程通信

	POSIX 也是一套进程通信的标准, 这套标准可以为操作系统提供达成进程通信的接口, 也非本篇文章的主要内容

本篇文章的主要内容, 是 pipe管道通信, 不会涉及到 System V 和 POSIX 进程通信

# 管道

在正式介绍管道之前, 先来简单分析一下, 进程怎么样通信的？

进程是拥有自己的进程地址空间的, 也就是说进程之间, 不能像我们人与人之间直接面对面说话.

但进程终究是在操作系统中运行着, 并且使用着操作系统的各种资源. 那么, `进程之间是否可以通过操作系统中的资源进行通信`呢？

就像 一个进程向文件中写入内容, 另一个进程从同一个文件中读取内容：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230324114404251.png" alt="image-20230324114404251" style="zoom:80%;" />

这个过程中, 我们通过访问同一个文件资源, 达成了一个进程向另一个进程传递数据的目的, 那这其实就是一种广义上的进程通信.

那么也就是说, 进程通信的前提其实是 `不同进程需要先能够看到、能够获取同一份资源(文件、内存等)`

**`这个资源 的种类, 其实就决定了进程通信的方式`**

管道, 就是提供资源的一种手段, 管道其实是一种文件资源

## 什么是管道？

管道, 是Unix中最古老的进程间通信的方式

管道, 其实就是 **`一个进程连接到另一个进程的数据流`**. 就像我们生活中, 管道是输送资源的：石油、天然气等

而系统中的管道, 则是输送数据的.

就像这样：ps -ajx |grep 



我们使用管道, 将ps的数据传输到了grep中, 供grep筛选. 这之中, 管道就起到了传输数据的作用：



那么管道究竟是什么？

管道, 其实是 **`一个打开的文件`**. 但是这个文件很特殊, `向这个文件中写入数据实际上并不会真正写入磁盘`中.

在介绍Linux系统的文件描述符时, 查看了Linux系统中描述已打开文件的结构体`files_struct`, 其中存储着指向打开文件的数组`fd_array`, 此数组的类型是 `struct files*`. 

而这个 `files结构体`中, 直接或间接描述了文件的所有属性, 以及 此文件的缓冲区相关信息：

![image-20230324122704908](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230324122704908.png)

缓冲区信息中, 包含着描述文件的inode结构体, 而inode结构体中其实描述着一个联合体：
![image-20230324123236480](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230324123236480.png)

这个处于inode结构体中的联合体, 其实就是为了标识这个文件的类型, 其中pipe 就表示此文件的类型是管道文件.

> inode的此联合体, 可以表示三种文件：
>
> 1. i_pipe, 管道文件
> 2. i_dbev, 块设备(磁盘)文件
> 3. i_cdev, 字符设备文件: 键盘等

通过文件的inode可以系统可以辨别出打开的文件是管道文件.

而**`向管道文件中写入数据实际上并不会写入到磁盘上, 而是只写入到文件的缓冲区中`**, 因为管道文件主要是用来进程间通信的.

`这种不实际存储数据的行为特点, 其实也符合生活中管道的特点, 管道不能用来存储资源, 只能用来传输资源`

并且, 除了管道不实际存储资源以外, 管道还有一个特点：**`管道是单向传输的`**

这是管道的特点, Linux的管道也是遵循这个特点的, 也就是说, `两个进程间使用管道通信时, 其中一个进程若以只写方式打开管道, 那么另一个进程就只能以只读方式打开文件`.

![](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230325110131491.png)

或者也可以反过来, 不过`管道的两端只能是不同的打开方式`

管道的种类有两种：

1. 匿名管道
2. 命名管道

从管道种类的名字上其实就能判断出来两种管道文件的打开的方式 

## 匿名管道

匿名管道的创建, `不会指定打开文件的文件名、文件路径等, 即不会有目标的打开文件`

只是在内存中打开一个文件, 用于进程间的通信

而由于匿名管道是`非明确目标的文件`, 也就意味着两个完全不相关的进程是无法一起访问这个管道的, 因为`其他进程无法找到这个管道`.

这也就意味着, `匿名管道其实只能用于具有血缘关系的进程间通信, 即父子进程之间`

匿名管道用于父子进程之间的通信, 那么管道的创建流程大概就是：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230325180631728.png" alt="image-20230325180631728" style="zoom:60%;" />

![image-20230325180720445](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230325180720445.png)

![image-20230325180850724](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230325180850724.png)

也就是说, 匿名管道的创建应该是**`由父进程创建, 然后创建子进程继承父进程的管道, 然后再关闭管道的写入端或读取端`**

这样就创建了一个管道通信

然而, 相信许多人对于这个过程都会有许多的问题：

1. 为什么父子进程要分别以只读和只写方式打开两次文件, 然后再创建子进程呢？

	为什么不是父进程以一个方式打开, 子进程再以另一个方式打开呢？

	因为`子进程会以继承父进程的方式打开同一个文件, 即子进程打开文件的方式与父进程是相同的`

	那这样的话, 父子进程通过想要通过管道实现进程通信, 子进程就需要先关闭已打开的文件, 再以某种方式打开同一个文件

	这样比较麻烦, 如果在创建子进程之前, 父进程就已经以两种方式打开同一个文件, 那么再子进程创建之后, 只需要父进程关闭一个端口, 子进程关闭另一个端口就可以了

2. 必须父进程关闭读取端, 子进程关闭写入端吗？

	并不是的, 父子进程关闭哪个端口, 其实是**`根据需求`**关闭的.

	如果子进程要向父进程传输数据, 那么关闭读取端的就应该是子进程



### 创建匿名管道

Linux操作系统提供了一个接口：

![image-20230324230532528](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230324230532528.png)

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230325183110031.png" alt="image-20230325183110031" style="zoom:80%;" />

且, pipe(), 如果*`创建管道成功, 则返回0, 否则返回-1`*, 并设置errno

pipe系统调用的作用是, 打开一个管道文件. 其参数是一个**`输出型参数`**

在pipe系统调用**`执行成功之后, 参数数组内会存储两个元素`**：

1. pipe[0], 存储以 只读方式 打开管道时获得的fd
2. pipe[1], 存储以 只写方式 打开管道时获得的fd

之后就可以根据需求, 选择父子进程的端口关闭

此系统接口具体的使用, 可以参考下面这段代码：

```cpp
#include <iostream>
#include <unistd.h>
#include <cstring>

int main() {
    // 父进程 pipe()系统调用, 打开管道
    int pipeFd[2] = {0};
    int ret = pipe(pipeFd);
    if(ret != 0) {
        std::cerr << "pipe error" << std::endl;
        return 1;
    }

    // 创建子进程
    // 并让 父进程 通过管道 向子进程 传输数据
    pid_t id = fork();
    if(id < 0) {
        std::cerr << "fork error" << std::endl;
        return 2;
    }
    else if(id == 0) {
        // 子进程执行代码
        // 子进程接收数据, 所以关闭只写端口 pipeFd[1]
        close(pipeFd[1]);
        char buffer[1024];
        while (true)
        {    
            memset(buffer, 0, 1024);
            ssize_t s = read(pipeFd[0], buffer, sizeof(buffer)-1);
            if(s > 0) {
                // 读取成功
                buffer[s] = '\0';
                std::cout << buffer << std::endl;
            }
            else if(s == 0) {
                // 读取结束       
                std::cout << "父进程写入结束, 子进程读取也结束！" << std::endl;
                break;
            }
            else {
                // 读取失败
            }
        }
        
    }
    else {
        // 父进程执行代码
        // 父进程发送数据, 所以关闭只读端口 pipeFd[0]
        close(pipeFd[0]);
        // 父进程每秒写入一句, 共5句
        const char* msg = "你好子进程, 我是父进程, 我通过管道跟你通信, 此次发送编号:: ";
        int cnt = 0;
        while(cnt < 5) {
            char sendBuffer[1024];
            sprintf(sendBuffer, "%s %d", msg, cnt);
            write(pipeFd[1], sendBuffer, strlen(sendBuffer));
            sleep(1);
            cnt++;
        }
        std::cout << "父进程写入完毕" << std::endl;
    }

    return 0;
}
```

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1%E6%B5%8B%E8%AF%95.gif" alt="匿名管道通信测试" style="zoom:80%;" />

可以看到, 我们成功使用pipe()接口创建了匿名管道, 在父进程与子进程之间建立了通信

但是, 上面的这个例子, 我们代码中写的时：

1. 父进程每1s, 写入一次数据

	<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230325215305146.png" alt="image-20230325215305146" style="zoom:80%;" />

2. 子进程死循环读取父进程写的数据

	<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230325215158088.png" alt="image-20230325215158088" style="zoom:80%;" />

但是, 代码的执行结果是是什么？代码的执行结果**`并不是子进程死循环读取父进程写入到管道的内容`**

代码的结果像是, 子进程也每1s读取一次管道数据, 或是说 子进程等父进程新写入数据之后才会读取数据

这是什么原因呢？

**`在父进程没有向管道内写入数据时, 子进程在等待！父进程写入数据之后, 子进程才能read到管道内容, 子进程读取、打印数据是以父进程的节奏为主的`**

在父子进程对管道进行读写操作时, 是由顺序性的.

**`此顺序是：写入端必须先写入数据, 读取端才能够读取数据`**

也就是说, **`当管道内部无数据时, 读取端的进程将会进入阻塞状态, 直到写入端写入数据`**

读取端进入阻塞状态, 是因为 `当管道内无数据时, 读取端进程会被放入到管道文件的等待队列中等待文件资源`

相对应的, **`当管道内数据被写满时, 写入端的进程将会进入阻塞状态, 直到读取端读取数据`**

> pipe文件中, 存在等待队列：
>
> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230325221323595.png" alt="image-20230325221323595" style="zoom:80%;" />

可以通过修改父子进程的写入和读取数据的时间, 来验证一下管道文件是否存在读写顺序：

我们将, 父进程改为10s一写入, 再测试：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1%E9%A1%BA%E5%BA%8F%E6%B5%8B%E8%AF%95.gif" alt="匿名管道通信顺序测试" style="zoom:80%;" />

我们将, 子进程改为15s一读取, 再将父进程改为死循环写入并输出写入次数：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93%E5%86%99%E6%BB%A1%E6%B5%8B%E8%AF%95.gif" alt="匿名管道写满测试" style="zoom:80%;" />

可以看到, `当父进程存在一定的写入间隔时, 子进程读取管道数据也会根据父进程的写入间隔进行读取`

`当父进程将管道写满, 子进程还未读取时, 父进程不会再向管道中写入内容`

这是因为, pipe文件内部存在访问控制机制, 而对于无访问控制机制的文件, 则不会存在写入与读取的顺序

> pipe文件存在访问控制机制, 会将管道文件的读写顺序控制为：先写再读.
>
> 这其实也符合生活中的管道特点, **`管道中传输的资源可以看作是一次性流通的`**. 比如 向管道中倒入一瓶水, 这瓶水完全经过管道流通之后, 这瓶水就不在管道中了. 管道通信也是这样的, 当读取端读取过管道中存在的数据时, 就可以看作此数据已经流出管道了, 不能在被二次读取. 

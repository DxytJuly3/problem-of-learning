进程地址空间的设计使进程拥有一块独立的空间, 为进程增添了独立性 和 安全性.

但是, 各种进程在操作系统中运行时, 总逃不了可能某些进程之间需要进行交流. 而此时, 进程地址空间的存在又好像成为了进程之间通信的一层阻隔.

# 进程通信

关于什么是进程通信的问题, 在操作系统中, 进程通信实际上就是 **`不同进程之间传输、交换数据`**

那么为什么进程之间要通信呢？为了进程之间不互相干扰, 不是已经用进程地址空间将进程独立了吗？

## 为什么要有进程通信

虽然进程拥有自己的虚拟地址空间, 但是也并不能阻止进程之间可能存在通信的需求

比如：

1. 进程之间数据传输：

	一个进程需要将自身的数据 发送到 另一个进程; 或者 一个进程 需要 另一个进程的数据

2. 进程需要共享资源：

	就像可能多个进程可以同时使用加载到内存中的动态库代码一样

3. 通知事件

	就比如, 在Linux中, 子进程运行终止 需要告诉父进程运行结果

4. 进程控制另一个进程：

	比如, 我们在使用程序调试代码的时候, 其实就是一个进程完全控制了另一个进程的执行, 让我们可以在进程运行时打上断点、执行下一个语句等

5. ……

这些都是进程通信的需求, 有需求那么就要提供方法.

## Linux进程通信方法

Linux为我们提供了三种进程间通信的方法：

1. `pipe 管道通信`

	管道通信相信许多人已经用过了, 在命令行中的标志就是: `|`: 

	![image-20230324112501490](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230324112501490.png)

	管道通信一般用来进程之间传输数据.

	比如在上面的例子中, 我们将ps 进程执行的数据通过管道传输给了 grep, 才能筛选出指定的内容

	管道通信又分为：`匿名管道` 和 `命名管道`

	管道通信是本片文章的主要内容

2. System V 进程通信

	System V 是一套进程通信的标准, 可以为操作系统提供进程通信的接口, 非本篇文章的主要内容

3. POSIX 进程通信

	POSIX 也是一套进程通信的标准, 这套标准可以为操作系统提供达成进程通信的接口, 也非本篇文章的主要内容

本篇文章的主要内容, 是 pipe管道通信, 不会涉及到 System V 和 POSIX 进程通信

# 管道

在正式介绍管道之前, 先来简单分析一下, 进程怎么样通信的？

进程是拥有自己的进程地址空间的, 也就是说进程之间, 不能像我们人与人之间直接面对面说话.

但进程终究是在操作系统中运行着, 并且使用着操作系统的各种资源. 那么, `进程之间是否可以通过操作系统中的资源进行通信`呢？

就像 一个进程向文件中写入内容, 另一个进程从同一个文件中读取内容：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230324114404251.png" alt="image-20230324114404251" style="zoom:80%;" />

这个过程中, 我们通过访问同一个文件资源, 达成了一个进程向另一个进程传递数据的目的, 那这其实就是一种广义上的进程通信.

那么也就是说, 进程通信的前提其实是 `不同进程需要先能够看到、能够获取同一份资源(文件、内存等)`

**`这个资源 的种类, 其实就决定了进程通信的方式`**

管道, 就是提供资源的一种手段, 管道其实是一种文件资源

## 什么是管道？

管道, 是Unix中最古老的进程间通信的方式

管道, 其实就是 **`一个进程连接到另一个进程的数据流`**. 就像我们生活中, 管道是输送资源的：石油、天然气等

而系统中的管道, 则是输送数据的.

就像这样：ps -ajx |grep 



我们使用管道, 将ps的数据传输到了grep中, 供grep筛选. 这之中, 管道就起到了传输数据的作用：



那么管道究竟是什么？

管道, 其实是 **`一个打开的文件`**. 但是这个文件很特殊, `向这个文件中写入数据实际上并不会真正写入磁盘`中.

在介绍Linux系统的文件描述符时, 查看了Linux系统中描述已打开文件的结构体`files_struct`, 其中存储着指向打开文件的数组`fd_array`, 此数组的类型是 `struct files*`. 

而这个 `files结构体`中, 直接或间接描述了文件的所有属性, 以及 此文件的缓冲区相关信息：

![image-20230324122704908](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230324122704908.png)

缓冲区信息中, 包含着描述文件的inode结构体, 而inode结构体中其实描述着一个联合体：
![image-20230324123236480](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230324123236480.png)

这个处于inode结构体中的联合体, 其实就是为了标识这个文件的类型, 其中pipe 就表示此文件的类型是管道文件.

> inode的此联合体, 可以表示三种文件：
>
> 1. i_pipe, 管道文件
> 2. i_dbev, 块设备(磁盘)文件
> 3. i_cdev, 字符设备文件: 键盘等

通过文件的inode可以系统可以辨别出打开的文件是管道文件.

而**`向管道文件中写入数据实际上并不会写入到磁盘上, 而是只写入到文件的缓冲区中`**, 因为管道文件主要是用来进程间通信的.

`这种不实际存储数据的行为特点, 其实也符合生活中管道的特点, 管道不能用来存储资源, 只能用来传输资源`

管道的种类有两种：

1. 匿名管道
2. 命名管道

从管道种类的名字上其实就能判断出来两种管道文件的打开的方式 

## 匿名管道

匿名管道的创建, `不会指定打开文件的文件名、文件路径等, 即不会有目标的打开文件`

只是在内存中打开一个文件, 用于进程间的通信

而由于匿名管道是`非明确目标的文件`, 也就意味着两个完全不相关的进程是无法一起访问这个管道的, 因为`其他进程无法找到这个管道`.

这也就意味着, `匿名管道其实只能用于具有血缘关系的进程间通信, 即父子进程之间`

匿名管道用于父子进程之间的通信, 那么管道的创建流程大概就是：



也就是说, 匿名管道的创建应该是由父进程创建, 然后创建子进程继承父进程的管道.

然后再关闭管道的写入端或读取端

然而, 相信许多人对于这个过程都会有许多的问题：

1. 为什么父子进程要分别以只读和只写方式打开两次文件, 然后再创建子进程呢？
2. 必须父进程关闭读取端, 子进程关闭写入端吗？

### 创建匿名管道

Linux操作系统提供了一个接口：

![image-20230324230532528](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20230324230532528.png)

pipe系统调用会让进程打开同一个文件

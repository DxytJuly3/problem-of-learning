上一篇文章详细介绍了C++的继承，继承是面向对象的三大特性之一。但是C++继承里面有一些坑是为C++的多态服务的。比如，继承类的析构函数构成隐藏，为什么？有什么意义？为什么父类对象不能直接复制给子类对象，而父类指针和父类对象可以赋值给子类指针和子类引用？这些问题 都可以在多态中解答

多态我打算用两篇文章来介绍，一篇 **只涉及使用**，而另一篇则更深入的去了解一些原理

本篇文章是C++ 多态介绍的第一篇文章，也是涉及 **C++多态使用** 的一篇

下面就来介绍一下多态：

# 什么是多态？

再生活中你一定遇到过，同一件事但是面对不同的对象却有着不同执行策略，比如 出去旅游去景区买票时，不同类型的人，票价一般是不同的：普通人一般是全价，而学生一般是半价，不足1.2米的儿童、60/70岁以上老人免票 或者 军人优先购票、半价等等

这就是 同一件事情，但是对不同的对象有着不同的执行策略。这就是生活中的多态

C++ 也可以通过多态来实现类似的场景，可能表现为：**不同的对象调用同一个函数，但是执行的结果不同**。

下面 就用C++ 多态来模拟实现一下，普通成年人、学生、军人、老人关于景区买票而可能会出现的多态场景

# 多态的使用

要实现多态调用，需要满足两个条件：

1. 必须是**父类的指针** 或 **父类的引用** 来调用 ***虚函数***
2. 被调用的函数必须是 ***虚函数***，并且 此 ***虚函数*** 必须被 ***重写***

这两个条件提及了两个名词 ：***虚函数*** 、***重写***

先介绍一下 **虚函数**
在上一篇文章中 接触了一个C++中的关键字 `virtual` ，用于 解决菱形继承的数据冗余和二义性的问题，将菱形继承改为 菱形虚拟继承
不仅是虚拟继承，**虚函数** 也是使用 关键字`virtual` 定义的

![image-20220724003532711](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220724003532711.png)

在上图的继承体系中，可以看到 四个类都存在一个函数名相同的成员函数 `buyTicket`

在普通的继承当中，父子类存在同函数名的函数 构成隐藏
但上图继承体系中，很明显的每个成员函数的函数名前都加了 `virtual`，**函数名前加 `virtual` 的函数被称为虚函数**
父类中的虚函数，在子类中 如果存在 **同名、同返回值类型、同参数**的函数，则 **构成函数重写**，而不构成隐藏

> 什么是**重写**？
>
> C++ 类成员函数中 加 `virtual` 的函数被称为 **虚函数**
> 如果这个类存在子类，且其子类中 存在与父类中的虚函数 **函数名、函数参数、函数返回值类型 都相同** 的函数，则称**子类重写了父类的虚函数**，或 **父类虚函数被重写**
>
> 即 重写 是父类虚函数与子类函数的关系，且如果想要构成重写，这需要满足两个必要条件：
>
> 1. **父类中的函数必须是虚函数，即必须有 `virtual`**
> 2. 子类中的函数 **与父类中 虚函数的函数名、函数参数、函数返回值类型 都相等**
>
> 必须同时满足这两个条件，则称 子类重写了父类的虚函数
>
> > 子类中的函数 不写 `virtual`  也同样构成重写，但是建议写上可读性比较强

所以上图中的继承体系，`Person`类中的成员函数 **`virtual void buyTicket()`** 分别被 `Student`、`Elderly`、`Soldier`类中的  **`virtual void buyTicket()`** **重写** 了

既然构成了重写，就可以使用 父类指针或父类引用 来进行多态调用：
![image-20220724010331702](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220724010331702.png)

上述示例中，函数`BuyTicket(Person& per)` 使用 **父类引用作为参数**，在函数体内调用成员函数 `buyTicket`

四次调用分别传入 不同类型的对象作为参数，除Person对象之外，其他类型对象传参发生切片，也就意味着 函数中的Person& 是 **不同类型对象的Person部分的引用**

如果函数参数是 Person* 类型也是同理，即 **Person* 指向不同类型对象的Person部分**

所以，**父子类函数满足重写时，父类指针 或 父类引用 指向哪个对象，调用函数时 就会调用对应类中的函数**，这就是C++中的**多态调用**

## 相关问题

> 问题1：如果只是父类对象可不可以多态调用呢？
>
> 答案，不可以。
>
> 示例：
>
> ![image-20220724120222888](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220724120222888.png)
>
> 如果 父子类虚函数构成重写，但 **使用父类对象调用虚函数，则不构成多态**

> 问题2：如果虚函数不构成重写 构不构成多态？
>
> 答案：不构成。
>
> 示例：
>
> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220724115853621.png" alt="image-20220724115853621" style="zoom:80%;" />
>
> 如果 父子类函数之间**不构成重写**，即使使用 父类指针或父类引用，也是**不构成多态**的

所以说，***构成多态的两个条件缺一不可***

## 协变

C++ 规定，父子类虚函数 必须 **同函数名、同函数参数、同函数返回值类型**，才能**构成重写**

但其实有两个例外，可以让父子类虚函数的 **返回值类型不相同时也可以构成重写**

1. 当父类虚函数的**返回值类型是父类指针**时，子类虚函数**返回值类型可以是子类指针**，同样**构成重写**
2. 当父类虚函数的**返回值类型是父类引用**时，子类虚函数**返回值类型可以是子类引用**，也**构成重写**

![image-20220724121752693](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220724121752693.png)

如果将之前示例中的 继承体系 改为上面两种，重写同样成立：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220724122051967.png" alt="image-20220724122051967" style="zoom:80%;" />

而这种写法：父子类虚函数的返回值类型为父子类的指针或引用，重写依旧成立。被称为 **协变**

## 析构函数的多态

父子类中 一般的虚函数都可以指定函数名、函数参数、函数返回值类型，进而构成重写，在进而构成多态

在某种场景之下，析构函数也是需要构成多态的，用于方便不同类型对象的析构

但是 析构函数的函数名是指定的——为 `~类名()` ，怎么对析构函数进行重写呢？

还记得在介绍 C++ 继承的时候 提到过“
父子类中各自的析构函数**构成隐藏**，因为编译器会 **将父子类的析构函数统一为 `~destructor` **，并且 解释说这是为了多态的使用

现在看来，编译器已经为析构函数做好了准备，我们只需要将 **父子类的析构函数设置为虚函数** 就可以构成重写，进而构成多态了：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220724123822274.png" alt="image-20220724123822274" style="zoom:80%;" />

使用上面的 继承体系：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220724124119357.png" alt="image-20220724124119357" style="zoom:80%;" />

即使 析构函数显式定义 函数名不同，编译器也会将继承体系中的所有析构函数 统一为 `~destructor` 为多态做准备

## C++11: final、override

C++对虚函数重写的判定是非常严格的，稍有不注意可能就会发生一些运行错误。一个大的项目中，运行错误 通常是不容易找到的

所以，C++11中，对多态又增加了两个新的关键字：`final`  和  `override`

> **`final`**：
>
> 意为最终，作用也非常的简单：添加在 虚函数函数名之后，可以**禁止此虚函数被重写**，即表示 此函数已经是最终的函数不能再改变
>
> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220724203504336.png" alt="image-20220724203504336" style="zoom:80%;" />

> **`override`**
>
> `override` 的作用，则是 用于子类的虚函数 检查此虚函数是否完成了对父类虚函数的重写，**若没有完成重写，则报错**
>
> <img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220724204203458.png" alt="image-20220724204203458" style="zoom:80%;" />

# 抽象类

抽象一词有意思是，不具体的。这个意思用来描述抽象类也是非常合适的

不具体的类，其实就是不能实例化对象的类

什么样的类才能被称为抽象类？**包含纯虚函数的类是抽象类**

问题又来了，**什么是纯虚函数？**

C++ 规定，在一个**虚函数 函数名后 加上 `=0` 那么这个虚函数就变成了纯虚函数**

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/CSDN/image-20220724212416457.png" alt="image-20220724212416457" style="zoom:80%;" />


在阅读这篇文章之前，请思考一下对于下面的这些问题，你有一个准确清晰的认知吗？
1. 什么是函数栈帧？
2. 程序中的局部变量，是如何创建的？
3. 为什么局部变量不初始化会是随机值？
4. 函数传参，究竟是如何传参的？
5. 函数的形参和实参存在什么关系？
6. 函数是如何被调用的？
7. 函数被调用之后是如何返回的？

如果没有，请尝试阅读、分析、理解本篇文章。
读懂本篇文章将会提升你的“自我修养”。

> `程序运行背后的机制和由来，可以看作是程序员的一种“自我修养”。`
> **------ 程序员的自我修养 “链接、装载与库”**
# 栈与栈帧
## 什么是栈？
在操作系统中，栈是一个动态内存区域。
函数的中的局部变量，都存放在内存的栈区中。
栈区的使用，和数据结构中的栈使用规则相似：
压栈、出栈、先进后出。
栈区总是先使用高地址，再使用低地址，即栈区的使用是 `从高地址向低地址延伸` 的。
## 什么是栈帧？
从逻辑上讲，栈帧就是一个函数执行的环境。
栈会保存一个函数被调用所需要的维护信息，保存这些信息所用的信息空间，常被称为 `函数栈帧`。

每一个函数的调用，都会创建一个独立的栈帧。

维护函数栈帧，需要用 `两个寄存器` 来记录函数栈帧的大小，也可以叫 划定函数活动记录的范围 ，这两个寄存器存放的是地址，两个地址之间，就是函数的栈帧大小：
1. 寄存器 `ebp`：栈底指针
指向维护栈帧的高地址.
2. 寄存器 `esp`：栈顶指针
指向维护的栈帧的低地址，会随每次压栈自动向低地址延伸.

# 栈帧是如何创建的?
> 	以下均在Windows平台，VS2013编译环境下演示
> 不同平台，不同编译环境下的栈帧操作可能会有差异，但是逻辑相通。

创建一个最简单的可以观察函数栈帧的程序
（步骤划分越细，函数栈帧观察越容易）：
```c
#include <stdio.h>

int Add(int x, int y)
{
	int z = 0;
	z = x + y;

	return z;
}

int main()
{
	int a = 10;
	int b = 20;
	int c = 0;
	c = Add(a , b);

	return 0;
}
```
在对代码进行调试的时候，对函数栈帧调用进行查看，此时调用 mian 函数栈帧:
![SF_Main](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/SF_Main.png)

将光标继续向后走，走到 `21行` 之后跳到另外一个界面：
![main函数被调用](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/SF_main__CRTStartup_mainCRTStartup.png)
发现，`main` 函数并不是直接被计算机调用的，而是由另外一个函数所调用

向上翻阅代码，能看到 main 函数其实是在 `__mainCRTStartup` 函数中被调用
而 `__mainCRTStartup` 函数，又在 `mainCRTStartup` 函数中被调用
![__mainCRTStartup被调用](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/SF_mainCRTStartup_return.png)

所以 在调用 `main` 函数之前，其实已经调用了两个函数，也已经创建了两个函数的栈帧。但是这两个函数的栈帧创建的过程并不容易被看到，所以我们可以观察 main 函数的栈帧的创建来详细了解栈帧的创建。

重新回到，光标刚指向 `main` 函数的时候，`转到反汇编`：

![反汇编](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/SF_Main_Stack_Frames.png)
右边 `反汇编窗口的代码` ，其实就是 `main` 函数中，`从函数栈帧创建，到 main 函数结束` 的整个操作及顺序。

以动画形式演示：
 1. `main` 函数调用之前，`mainCRTStartup` 和 `__mainCRTStartup` 函数的栈帧创建(无详细内容)：
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/SF_MAINSRTSTARTUP_PUSH.gif" alt="简单main 函数栈帧创建" style="zoom: 60%;" />

 2. 进入 `main` 函数：
> 1. `(push ebp)` 压栈，压入内容是 `ebp` 指向的地址`(为保存当前 ebp 内容)``
> `ps：压栈之后，esp(栈顶指针)自动指向栈顶`
> 2. `(mov  ebp,esp)` 将 `ebp` 指向 `esp` 的地址( 将 `esp` 赋予 `ebp`)

此时，`ebp` 和 `esp` 的实际变化为：
> 未执行 :
> ![](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/push_esp_ebp_change.png)
> 执行 `push ebp` :
> ![](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/pushA_esp_ebp_change.png)
> 执行 `mov ebp,esp` :
> ![](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/mov_esp_ebp_change.png)

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/push_epb.gif" alt="压栈ebp，调整" style="zoom: 60%;" />
3. 此时，反汇编中的语句光标指向了 

`sub esp,0E4h`

![next_esp_sub](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/sub_esp.png)

即下一句执行指令的就是 `sub esp,0E4h`
> 汇编语言：`sub 相减`
> `sub esp,0E4h` 指 `esp = esp - 0E4h`
> `0E4h` 是十六进制数，转换成十进制为 228：![0E4h](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/0E4h.png)

执行`sub esp,0E4h` 的变化：
> 未执行：
> ![](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/No_sub.png)
> 执行 `sub esp,0E4h`：
> ![](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/sub_esp_change.png)

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/sub_esp_0E4h.gif" alt="sub esp,0E4h" style="zoom: 60%;" />

执行之后，`esp` 和 `ebp` 之间会 存在一块由其新维护的空间
而这段空间其实就是为 `main` 函数预开辟的空间

查看地址：
<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/For_main_space.png" alt="For_main_space" style="zoom: 80%;" />
即：从 `0x00AFF8A4` 到 `0x00AFF988` 就是为 `main` 函数与开辟的空间
也被成为 `main` 函数的栈帧。

但是，这里并不是函数栈帧创建的结束。

4. 继续执行汇编指令，光标继续移动：
![Push_ebx_esi_edi](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/Push_ebx_esi_edi.png)

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/Save_ebx_esi_edi.gif" alt="Save_ebx_esi_edi" style="zoom: 60%;" />

保存了寄存器`ebx` `esi` `edi`

5. 指令继续执行：
> 1. 执行 `lea edi,[ebp-0E4h]` ：
> ![lea_edi](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/lea_edi.png)
> 这里的 `ebp-0E4h` 地址，经过对比，就是 预开辟的 `main` 函数栈帧的栈顶地址`(0x00AFF8A4)`
>> 汇编指令 ：`lea(Load effect address)`   加载有效地址
>> `lea edi,[ebp-0E4h]`  即为：加载有效地址 `ebp-0E4h` 至寄存器`edi`
>
>2. 执行 `mov ecx,39h` 和 `mov eax,0CCCCCCCCh`
>![No_mov_ecx_eax](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/No_mov_ecx_eax.png)
> 👇👇👇
>![mov_ecx_eax](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/mov_ecx_eax.png)
> 寄存器 `ecx` 存入 `十六进制 39(十进制 57)`
> 寄存器 `eax` 存入`0xCCCCCCCC`
> 
> 3. 执行 `rep_stos  dword_ptr_es:[edi]`：
> ![rep_stos](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/rep_stos_change.png)
> 执行之后，从 `0x00AFF988 - 4` 到 `0x00AFF8A4` 的`(每4字节)`所有内容都被设置为了 `0xCCCCCCCC` ，即 开辟的`main` 栈帧中的所有内容被设置为 `0xCCCCCCCC` 
>> 汇编指令：
>> ```
>> lea         edi,[ebp-0E4h]  
>> mov         ecx,39h  
>> mov         eax,0CCCCCCCCh  
>> rep stos    dword ptr es:[edi]
>> ```
>> 这一段汇编指令中最后一句
>> `rep_stos    dword_ptr_es:[edi]`
>> `rep` ： 重复上面指令， 即 
>> ```
>> lea         edi,[ebp-0E4h]  
>> mov         ecx,39h  
>> mov         eax,0CCCCCCCCh
>> ```
>>  寄存器 `ecx` 中的值，即为重复的次数
>> `stos` ：将 `eax` 中的值拷贝到 `edi` 指向的地址
>>
>>> 指令执行时，默认 `edi` 中的地址，是增大的(向高地址增长)。所以，会从`edi [ebp-0E4h(0x00AFF8A4)]` 每4字节的增长，增长到 `0x00AFF988` 共 57次(寄存器 `ecx` 中存入的数据)
>
> `main` 函数栈帧中所有内容被 设置为了 `0xCCCCCCCC` 
> 那么 在 `main` 函数中 定义局部变量 而不初始化
> 局部变量就会表示随机值。
> 所以 输出一个未初始化的局部变量，很可能会出现：
> ![](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/0xCCCCCCCC.png)

到此，`main` 函数栈帧的创建全部完成。
接下来就是，局部变量的创建、调用函数栈帧的创建、函数传参、函数返回等。


# 局部变量是如何创建的？调用函数究竟是如何传参的？
以上，详细分析了 `main` 函数栈帧在内存中创建的过程。
创建完成之后，就会按照顺序执行 `main` 函数中的函数 或 语句。


接下来，就是局部变量在栈帧中的创建 和 函数被调用时传参的实现：

## 局部变量在栈帧中的创建
![Local_variables_creat_front](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/Local_variables_creat_front.png)
> `dword ptr` 表示地址内容为双字`(4字节)`数据

观察汇编代码，对 局部变量 `a`、 `b`、 `c` 的创建及初始化是从 地址`ebp-8` 开始的。
代码向下执行：
![Local_variables_creat](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/Local_variables_creat.png)

![Local_variables_creat](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/Local_variables_creat.gif)

局部变量的创建相对简单，一张动图就可以理解。

## 函数被调用时的传参
调用需要使用参数的函数时，需要传入存在的局部变量，作为函数的参数。
但是，被传入函数的参数，在函数中都被称为 `形参`，在被调用函数中 直接改变 并不能真正改变原来的变量，这是为什么？

真正的原因，就在这里：

---

![](https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/Stack_Frames/Add_No.png)
先分析汇编代码：
> ```
> mov        eax,dword ptr [ebp-14h]
> push       eax
>mov        ecx,dword ptr [ebp-8]
> push       ecx
> ```

# 2022-02-21 文件操作(2)

上一篇 介绍了 文件 按照功能的分类，文件的顺序、随机读写操作及其函数的使用。那么这一篇，我们就接着上篇文件操作的内容，介绍一下关于文件更深层次的知识：

---

## 一、文本文件 和 二进制文件	（1:34:10）

上一篇介绍过，文件按照功能分类，可以分为 `程序文件`、`数据文件` 两类。

此外，文件的分类还有其他的分类方法，比如 按照文件数据的组织形式 来分为 `二进制文件` 和 `文本文件`。

---

具体什么是文本文件，什么是二进制文件呢？

关于文本文件，一般我们自己创建并写入内容的文档，或者 Markdown 文件等，都是可以看懂内容的的，这些都属于文本文件的。

比如：

> 一个 `.txt` 文件:  <img src="C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20220303152813037.png" alt="image-20220303152813037" style="zoom: 80%;" />，或者 一个 `.md` 文件 <img src="C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20220303153058340.png" alt="image-20220303153058340" style="zoom:50%;" />

而对于二进制文件，一般人打开二进制文件是没有办法直接看懂的，因为大部分内容都是乱码，除非用二进制的编辑器打开才会显示二进制的形式，不过一般人还是无法看懂的



>类似这样：![image-20220303155728056](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20220303155728056.png)
>
>这样：
>
>![image-20220303155824824](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20220303155824824.png)
>
>或者这样：
>
>![image-20220303160145070](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20220303160145070.png)
>
>类似于，这些文件，一般人（反正我是）真的看不懂。

这时候可能有人会说

> 那 文本文件不就是，打开后 一般人能看懂的文件
>
> 二进制文件不就是，打开后内容都是二进制或者乱码形式的一般人看不懂的文件吗

啊，确实

但是身为新时代青年的我们，不能这样简单的区分

我们要知道，文本文件 和 二进制文件  在内存中都是如何存储的

虽然两种文本的内容在内存中都是以二进制的形式存储的，但是存储的方式又有其他不同。

#### `文本文件在内存中的存储`

> 文本文件，我们可以直接打开看懂，主要是因为 文本文件存入内存的二进制数据是经过转换的。
>
> 在文本文件的内容 存入内存之前，文本文件的所有内容 都会转换为 `ASCII 码` 的形式，然后再 以 `ASCII 码` 的二进制数据存入内存中。
>
> 然后当使用者打开文本文件的时候，也是会经过转换再显示的。

#### `二进制文件在内存中的存储`

> 二进制文件，直接打开一般都是乱码
>
> 是因为，二进制文件的内容，不会全部以 `ASCII 码` 的形式存入内存中
>
> 而我们直接打开二进制文件，文件内容也不会经过转换再展现给我们
>
> 直接是一堆乱码



看完这些，相信都可以理解究竟什么是二进制文件，什么是文本文件了吧！

---

## 二、文件读取结束的判定

当我们对一个文件的数据进行读取，输入到内存中的时候，无论是读取文件数据正常结束，还是读取文件数据失败了，函数都会返回一个值。

对于一般的文本文件：

>  以 `fgetc 字符输入函数 `读取：
>
> > 读取文件数据结束 或者 读取文件数据失败 就会返回 `EOF`
>
>  以 `fgets 文本行输入函数` 读取：
>
> > 读取文件数据结束 或者 读取文件数据失败 就会返回 `NULL`

对于二进制文件：

> 以 `fread 二进制输入函数` 读取：
>
> > 读取文件结束 就会返回 最后一次读取到的数据的个数

### 2.1  被大家错误使用的`feof`

文件读取结束，有可能是 读取失败结束， 也有可能是读取到结尾后结束。但是文件读取函数，无论是以那种方式结束，函数的返回值都是一样的。很可能就无法判断，文件的读取到底是如何结束的。

所以，就要使用到两个 用来判定文件读取结束方式 的函数 

`feof` 和 `ferror`

---



#### `feof`

```C
int feof( FILE *stream );
```

当文件读取结束后，可以将 文件指针(文件流)，传入 `feof` 函数，然后以 `feof` 的返回值来判断 文件读取是否属于 非读取失败 结束的。

 `feof` 的返回值只有 `0` 和 `非零值`

> 当 文件读取 属于正常的读取到末尾结束的 ，`feof` 就返回一个 `非零值`
>
> 当 文件读取 还没有读取到末尾， `feof` 就返回 `0`
>
> 当 文件读取 属于读取失败结束的， `feof` 无返回

但是，对于 `feof` 许多人将其用于 判断文件的读取是否结束，而不是用于 判读文件读取是以哪种方式结束的

其实，`feof` 真正正确的用法是， 在已经知道文件读取结束(已经读取失败(错误)，或是已经读取到文件数据的末尾)的情况下，用 `feof` 判断文件读取是否是 正常的读取结束

而 `ferror` 函数，则是用来判断 文件读取 是否属于 读取失败结束

#### `ferror`

```C
int ferror( FILE *stream );
```

`ferror` 和 `feof` ，两个函数一般结合使用

当 文件读取已经结束(已经读取失败(错误)，或是已经读取到文件数据的末尾)的情况下，将 `文件指针(文件流)` 分别传入 `ferror` 和 `feof` ，通过判断 两个函数的返回值，来判断文件读取结束的方式。

`ferror` 的返回值同样也只有 `0` 和 `非零值`

> 当 文件读取 属于正常的 读取到末尾结束的， `ferror` 就返回 `0`
>
> 当 文件读取 属于读取失败(错误)结束的， `ferror` 就返回一个 `非零值`



大家可以用下面的两段代码（也可以根据自己的经验，知识稍作修改）试验一下

>对于文本文件：
>
>```C
>#include <stdio.h>
>#include <stdlib.h>
>
>int main()
>{
>	int c; // 注意：int，非char，要求处理EOF
>	FILE* pf = fopen("test.txt", "r");
>	if(pf == NULL)
>    {
>		perror("File opening failed");
>		return 0;
>	}
>	//fgetc 当读取失败的时候或者遇到文件结束的时候，都会返回EOF
>	while ( (c = fgetc(pf)) != EOF) // 标准C I/O读取文件循环
>	{
>		putchar(c);
>	}
>    
>    //判断是什么原因结束的
>	if (ferror(pf))
>		puts("I/O error when reading");
>	else if (feof(pf))
>		puts("End of file reached successfully");
>    
>	fclose(pf);
>    pf = NULL;
>    
>    return 0;
>}
>```
>
>对于二进制文件：
>
>```C
>#include <stdio.h>
>
>int main()
>{
>	double a[5] = { 1.0, 2.0, 3.0, 4.0, 5.0 };
>	FILE *pf = fopen("test.bin", "wb"); // 必须用二进制模式
>    if(pf == NULL)
>    {
>		perror("File opening failed");
>		return 0;
>	}
>	fwrite(a, sizeof (*a), SIZE, pf); // 写 double 的数组
>	fclose(pf);
>    pf = NULL;
>    
>	double b[5];
>	pf = fopen("test.bin","rb");
>	size_t ret_code = fread(b, sizeof (*b), 5, pf); // 读 double 的数组
>    if(pf == NULL)
>    {
>		perror("File opening failed");
>		return 0;
>	}
>	if(ret_code == 5)
>    {
>		puts("Array read successfully, contents: ");
>		for(int n = 0; n < SIZE; ++n)
>         	printf("%f ", b[n]);
>		putchar('\n');
>	}
>    else
>    { // error handling
>		if (feof(pf))
>        {//判断是否正常结束
>        	printf("Error reading test.bin: unexpected end of file\n");   
>        }
>		else if (ferror(pf))
>        {//判断是否遇到错误结束
>			perror("Error reading test.bin");
>		}
>	}
>    
>	fclose(pf);
>    pf = NULL;
>    
>    return 0;
>}	
>```
>
>可以修改一下，使两个函数 都生效以下~

## 三、文件缓冲区




# 2022-02-21 文件操作(2)

上一篇 介绍了 文件 按照功能的分类，文件的顺序、随机读写操作及其函数的使用。那么这一篇，我们就接着上篇文件操作的内容，介绍一下关于文件更深层次的知识：

---

## 一、文本文件 和 二进制文件	（1:34:10）

上一篇介绍过，文件按照功能分类，可以分为 `程序文件`、`数据文件` 两类。

此外，文件的分类还有其他的分类方法，比如 按照文件数据的组织形式 来分为 `二进制文件` 和 `文本文件`。

---

具体什么是文本文件，什么是二进制文件呢？

关于文本文件，一般我们自己创建并写入内容的文档，或者 Markdown 文件等，都是可以看懂内容的的，这些都属于文本文件的。

比如：

> 一个 `.txt` 文件:  <img src="C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20220303152813037.png" alt="image-20220303152813037" style="zoom: 80%;" />，或者 一个 `.md` 文件 <img src="C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20220303153058340.png" alt="image-20220303153058340" style="zoom:50%;" />

而对于二进制文件，一般人打开二进制文件是没有办法直接看懂的，因为大部分内容都是乱码

除非用二进制的编辑器打开才会显示二进制的形式，不过一般人还是无法看懂的

>类似这样：![image-20220303155728056](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20220303155728056.png)
>
>这样：
>
>![image-20220303155824824](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20220303155824824.png)
>
>或者这样：
>
>![image-20220303160145070](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20220303160145070.png)
>
>类似于，这些文件，一般人（反正我是）真的看不懂。

这时候可能有人会说

> 那 文本文件不就是，打开后 一般人能看懂的文件
>
> 二进制文件不就是，打开后内容都是二进制或者乱码形式的一般人看不懂的文件吗

啊，确实

但是身为新时代青年的我们，不能这样简单的区分

我们要知道，文本文件 和 二进制文件  在内存中都是如何存储的

虽然两种文本的内容在内存中都是以二进制的形式存储的，但是存储的方式又有其他不同。

#### `文本文件在内存中的存储`

> 文本文件，我们可以直接打开看懂，主要是因为 文本文件存入内存的二进制数据是经过转换的。
>
> 在文本文件的内容 存入内存之前，文本文件的所有内容 都会转换为 `ASCII 码` 的形式，然后再 以 `ASCII 码` 的二进制数据存入内存中。
>
> 也就是，对于文本文件的内容：
>
> > 字符类型、数值类型的数据，都会按位转换为 对应的 `ASCII码` ，然后将 `ASCII码`对应的二进制数据，存储到内存中
>
> 然后当使用者打开文本文件的时候，也是会经过转换再显示的。

#### `二进制文件在内存中的存储`

> 二进制文件，直接打开一般会有一部分乱码
>
> 是因为，二进制文件的内容，不会全部以 `ASCII 码` 的形式存入内存中，只有字符型的数据，会转换为相应的 `ASCII码` 再存储至内存。
>
> 所以直接打开二进制文件，字符型以外的数据 就会以乱码的形式展现给用户。
>
> > 或许会有 打开二进制文件 却发现中文内容也变成了乱码，那可能是文件内容编码不合适导致的

#### `数据在内存中的存储`

> 介绍完 `文本文件` 和 `二进制文件`，会发现有一个共同点：
>
> 字符型的数据，都会先转换为 `ASCII码` 之后，在存储 `ASCII码` 的二进制数据。
>
> 其实是因为，数据在内存中的存储具体是这样的：
>
> > 1. 字符型的数据，都会 以其对应的 `ASCII码` 的二进制存储至内存中
> > 2. 数值型的数据，可以 以其对应的 `ASCII码` 的二进制存储至内存中（文本文件），也可以 直接以数值本身的二进制形式存储至内存中 
>
> 那么，数值型的数据 的两种不同形式的存储 有没有什么区别呢？
>
> 答案是有的！
>
> 举例说明：
>
> > 当 我们需要将 99999 存储起来，可以用两种形式：
> >
> > > 1. 以 `ASCII码` 的形式存储：
> > >
> > >    需要将`9` `9` `9` `9` `9` 分别转换为字符，然后存储其对应的 `ASCII码`的二进制
> > >
> > >    即：![image-20220306084415701](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20220306084415701.png)
> > >
> > >    `VS2013`:![image-20220306090033211](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20220306090033211.png)
> > >
> > > 2. 直接以数值的二进制存储：
> > >
> > >    即：![image-20220306085041671](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20220306085041671.png)
> > >
> > >    `VS2013`：对文件中以二进制输出 `99999`
> > >
> > >    ![image-20220306102249492](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20220306102249492.png)
> > >
> > >    ![image-20220306102445408](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20220306102445408.png)
> >
> > 我们可以非常明确的看到，对于同一个数值型数据，以 `99999` 为例
> >
> > 如果以 `ASCII码`形式 存储，占用 5 字节 内存
> >
> > 如果直接以 数值的二进制形式 存储，占用 4 字节 内存
> >
> > 所以，数值型数据的两种不同的存储方式，在内存方面 是有一定的区别的。

看完这些，相信都可以理解究竟什么是二进制文件，什么是文本文件了吧！

---

## 二、文件读取结束的判定

当我们对一个文件的数据进行读取，输入到内存中的时候，无论是读取文件数据正常结束，还是读取文件数据失败了，函数都会返回一个值。

对于一般的文本文件：

>  以 `fgetc 字符输入函数 `读取：
>
> > 读取文件数据结束 或者 读取文件数据失败 就会返回 `EOF`
>
>  以 `fgets 文本行输入函数` 读取：
>
> > 读取文件数据结束 或者 读取文件数据失败 就会返回 `NULL`

对于二进制文件：

> 以 `fread 二进制输入函数` 读取：
>
> > 读取文件结束 就会返回 最后一次读取到的数据的个数

### 2.1  被大家错误使用的`feof`

文件读取结束，有可能是 读取失败结束， 也有可能是读取到结尾后结束。但是文件读取函数，无论是以那种方式结束，函数的返回值都是一样的。很可能就无法判断，文件的读取到底是如何结束的。

所以，就要使用到两个 用来判定文件读取结束方式 的函数 

`feof` 和 `ferror`

---



#### `feof`

```C
int feof( FILE *stream );
```

当文件读取结束后，可以将 文件指针(文件流)，传入 `feof` 函数，然后以 `feof` 的返回值来判断 文件读取是否属于 非读取失败 结束的。

 `feof` 的返回值只有 `0` 和 `非零值`

> 当 文件读取 属于正常的读取到末尾结束的 ，`feof` 就返回一个 `非零值`
>
> 当 文件读取 还没有读取到末尾， `feof` 就返回 `0`
>
> 当 文件读取 属于读取失败结束的， `feof` 无返回

但是，对于 `feof` 许多人将其用于 判断文件的读取是否结束，而不是用于 判读文件读取是以哪种方式结束的

其实，`feof` 真正正确的用法是， 在已经知道文件读取结束(已经读取失败(错误)，或是已经读取到文件数据的末尾)的情况下，用 `feof` 判断文件读取是否是 正常的读取结束

而 `ferror` 函数，则是用来判断 文件读取 是否属于 读取失败结束

#### `ferror`

```C
int ferror( FILE *stream );
```

`ferror` 和 `feof` ，两个函数一般结合使用

当 文件读取已经结束(已经读取失败(错误)，或是已经读取到文件数据的末尾)的情况下，将 `文件指针(文件流)` 分别传入 `ferror` 和 `feof` ，通过判断 两个函数的返回值，来判断文件读取结束的方式。

`ferror` 的返回值同样也只有 `0` 和 `非零值`

> 当 文件读取 属于正常的 读取到末尾结束的， `ferror` 就返回 `0`
>
> 当 文件读取 属于读取失败(错误)结束的， `ferror` 就返回一个 `非零值`



大家可以用下面的两段代码（也可以根据自己的经验，知识稍作修改）试验一下

>对于文本文件：
>
>```C
>#include <stdio.h>
>#include <stdlib.h>
>
>int main()
>{
>	int c; // 注意：int，非char，要求处理EOF
>	FILE* pf = fopen("test.txt", "r");
>	if(pf == NULL)
>    {
>		perror("File opening failed");
>		return 0;
>	}
>	//fgetc 当读取失败的时候或者遇到文件结束的时候，都会返回EOF
>	while ( (c = fgetc(pf)) != EOF) // 标准C I/O读取文件循环
>	{
>		putchar(c);
>	}
>    
>    //判断是什么原因结束的
>	if (ferror(pf))
>		puts("I/O error when reading");
>	else if (feof(pf))
>		puts("End of file reached successfully");
>    
>	fclose(pf);
>    pf = NULL;
>    
>    return 0;
>}
>```
>
>对于二进制文件：
>
>```C
>#include <stdio.h>
>
>int main()
>{
>	double a[5] = { 1.0, 2.0, 3.0, 4.0, 5.0 };
>	FILE *pf = fopen("test.bin", "wb"); // 必须用二进制模式
>    	if(pf == NULL)
>    	{
>		perror("File opening failed");
>		return 0;
>	}
>	fwrite(a, sizeof (*a), SIZE, pf); // 写 double 的数组
>	fclose(pf);
>    	pf = NULL;
>    
>	double b[5];
>	pf = fopen("test.bin","rb");
>	size_t ret_code = fread(b, sizeof (*b), 5, pf); // 读 double 的数组
>    	if(pf == NULL)
>    	{
>		perror("File opening failed");
>		return 0;
>	}
>	if(ret_code == 5)
>    	{
>		puts("Array read successfully, contents: ");
>		for(int n = 0; n < SIZE; ++n)
>         	printf("%f ", b[n]);
>		putchar('\n');
>	}
>    	else
>    	{ // error handling
>		if (feof(pf))
>        		{//判断是否正常结束
>        			printf("Error reading test.bin: unexpected end of file\n");   
>        		}
>		else if (ferror(pf))
>        		{//判断是否遇到错误结束
>			perror("Error reading test.bin");
>		}
>	}
>    
>	fclose(pf);
>    	pf = NULL;
>    
>    	return 0;
>}	
>```
>
>可以修改一下，使两个函数 都生效以下~

## 三、文件缓冲区

关于`文件缓冲区` 先来理解一下是怎么形成的：

现行 `ANSIC 标准` 是采用`“缓冲文件系统”`处理数据文件的，所谓`缓冲文件系统`是指系统自动地在内存中为程序中每一个正在使用的文件开辟一块 `“文件缓冲区”`。

文件缓冲区的作用：

从 `内存` 向 `磁盘` 输出数据 会先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘上。

如果从 `磁盘` 向 `计算机` 读入数据，则从 磁盘文件中 读取数据输入 到内存缓冲区（充满缓冲区），然后再从 缓冲区逐个地 将数据送到程序数据区（程序变量等）。缓冲区的大小根据C编译系统决定的。  


# 文件缓冲区

关于`文件缓冲区` 先来理解一下是怎么形成的：

现行 `ANSIC 标准` 是采用`“缓冲文件系统”`处理数据文件的，所谓`缓冲文件系统`是指系统自动地在内存中为程序中每一个正在使用的文件开辟一块 `“文件缓冲区”`。

文件缓冲区的作用：

从 `内存` 向 `磁盘` 输出数据 会先送到内存中的缓冲区，装满缓冲区后才一起送到磁盘上。

如果从 `磁盘` 向 `计算机` 读入数据，则从 磁盘文件中 读取数据输入 到内存缓冲区（充满缓冲区），然后再从 缓冲区逐个地 将数据送到程序数据区（程序变量等）。缓冲区的大小根据C编译系统决定的。 

当然，并不是只有在缓冲区被装满的时候，在会执行缓冲区的命令，可以通过手动刷新缓冲区来执行缓冲区中的命令。在一个程序结束的时候，也会刷新清除缓冲区。 换行、以及 fclose 函数也会刷新缓冲区。

文件缓冲区的存在，可以减轻系统的压力。为什么呢？举个栗子：

比如，

执行一个C语言代码，需要在屏幕上打印信息，会用到 printf 函数

这个函数会调用系统调用api，通过系统调用api让操作系统在屏幕上打印信息

但是，如果需要很多次使用 printf，同时也没有缓冲区的存在，那么函数就会频繁的通过系统调用api麻烦操作系统来执行它的命令。但是操作系统并不是只执行这一个程序的，如果只一个程序就频繁的麻烦操作系统，那么如果有更多的程序，操作系统就会承受更多的压力，频繁跳跃与不同的命令。

如果存在缓冲区，那么一个程序中的命令，就会先存储到缓冲区中，当缓冲区被装满之后，再由操作系统 统一执行操作。

类似于问问题，频繁的问问题会让被提问者无法继续当前正在进行的事情。如果存够一定的问题再提问，并且一次性解决，会大大降低提问者和被提问者的压力。

那么怎么证明缓冲区的存在呢？？

在 Windows平台：

```c
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <Windows.h>

int main()
{
	FILE* pf = fopen("test.txt", "w");
	if (pf == NULL)
	{
		printf("fopen failed::%s", strerror(errno));
	}

	fputs("Hello Bit", pf);
	Sleep(10000);

	fclose(pf);
	pf = NULL;
	

	return 0;
}
```

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-BUFFER-WINDOWS.gif" alt="Windows 平台缓冲区展示" style="zoom:50%;" />

可以看出，在程序编译运行的前5秒，文件中是没有内容的，文件的大小也是 0KB，在程序结束之后，缓冲区虽然并未被装满但是强制被刷新清空，文件中被写入内容。

Linux 平台：

<img src="https://dxyt-july-image.oss-cn-beijing.aliyuncs.com/FILE_CONTROL/file-BUFFER-LINUX.gif" alt="Linux 平台缓冲区展示" style="zoom:50%;" />

可以看出，printf 结尾 有换行符的，都会直接刷新缓冲区，所以每次printf语句执行，都会输出 Hello Bit，但是后面的几句，结尾都没有换行符，所以缓冲区会在程序结束的时候刷新，所以 后面的 Hello Bit，都会在程序结束的时候输出。 

[[文件读取结束的判定]]
[[文件操作]]
[[文本文件及二进制文件]]
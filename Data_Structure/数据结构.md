

1. 数据结构(DataStrctue)是相互之间存在一种或多种特定关系的数据元素的集合

2. ![四类基本逻辑结构关系图](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20211210144144818.png)若是分两种，就只有线性结构、非线性结构

3. 顺序存储结构是借助元素在存储器中的相对位置来表示数据元素之间的逻辑关系  

4. 顺序存储结构要求所有的元素依次存放在一片连续的存储空间中， 而链式存储结构，无需占
   用一整块存储空间。  

5. 线性表的顺序存储结构是一种随机存取的存储结构。  

6. ```c
	//－ － － － － 线性表的存储结构－ － － － －
	#define MAXSIZE 100
	typedef struct
	{
		ElemType *elem;    	//存储空间的基地址
		int length;			//存储空间的基地址
	}SqList;				//顺序表的结构类型为SqList
	```


7. ```c
    //－ － － － － 单链表的存储结构－ － － － －
      typedef struct LNode
      {
           ElemType data; 			//结点的数据
      		struct LNode *next;		//结点的指针域
      }LNode,*LinkList;		//LinkList 为指向结构体 LNode 的指针类型 
   ```
   
7. 存储密度是指数据元素本身所占用的存储量和整个结点结构所占用的存储量之比，即 
   ![image-20211210145426030](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20211210145426030.png)
   
9. 

   ![](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20211210145511095.png)

10. 栈  是限定仅在表尾进行插入或删除操作的线性表 ,后进先出 的线性表  

![image-20211210145656612](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20211210145656612.png)

11. 队列(queue)是一种先进先出(First In First Out, FIFO)的线性表  只允许在表的一端进行插入，而在另一端删除元素  

    ![image-20211210145923576](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20211210145923576.png)

12. 递归是指，若在一个函数、 过程或者数据结构定义的内部又直接（或间接）出现定义本身的应用， 则称它们是递归的 ， 或者是递归定义的  

13. ```c
    // － － － － － 队列的顺序存储结构－ － － － －
    #define MAXQSIZE 100
    typedef struct
    {
    	QElemType *base;		//存储空间的基地址
    	int front;				//头指针
    	int rear;				//尾指针
    }SqQueue;
    ```

    

14. ![image-20211210150211621](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20211210150211621.png)队列处于如图  所示的状态 时不可再继续插入新的队尾元素，否则会出现溢出现象，事实上，此时队列的实际可用空间并未占满，所以这种现象称为 “假溢出＂。  

    解决方法：将顺序队列变为一个环状的空间 ，如图 ![image-20211210150422946](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20211210150422946.png)所示，称 之为循环队列。  

15. 循环队列中队空和队满的条件是：
    队空的条件： Q.front =Q.rear
    队满的条件： (Q rear+ 1)%M心CQSIZE = Q.front  

16. 字符串一般简称为串 ,

17. 串是一种特殊的线性表， 其特殊性体现在数据元素是一个字符， 也就是说， 串是一种内容受限的线性表  

18. 广义表是线性表的推广

    取表头 GetHead(LS): 取出的表头为非空广义表的第一个元素，它可以是一个单原子，也
    可以是一个子表。  

    取表尾 GetTail(LS): 取出的表尾为除去表头之外，由其余元素构成的表。 即表尾一定是
    一个广义表。  

19. # 二叉树 

     ## 二叉树的基本形态 ![image-20211210152529424](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20211210152529424.png)

    ## 二叉树树的性质

    	#### 		性质1

    ​			在二叉树的 第 i 层上至多有![image-20211210153338573](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20211210153338573.png) 个结点（i >= 1)

    

    	#### 		性质2 

    ​			深度为k 的 二叉树至多有 ![image-20211210153321039](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20211210153321039.png)个结点  （i >= 1) 

    
    
    	#### 		性质3 				
    
    ​			对任何一棵二叉树T, 如果其终端结点数为![image-20211210153357971](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20211210153357971.png)，度为 2 的结点数为![image-20211210153410391](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20211210153410391.png) , 则![image-20211210153429070](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20211210153429070.png) 
    
    
    
    ### 	满二叉树
    
    #### 		定义：
    
    ​			深度为 K 且含有 ![image-20211210154351356](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20211210154351356.png) 个结点的二叉树
    
    ​												  ![image-20211210154406725](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20211210154406725.png)
    
    #### 		特点：
    
    ​			每一层上的结点数都是最大结点数，即每一层l的结点数都具有最大值 ![image-20211210154351356](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20211210154351356.png)
    
    
    
    ### 完全二叉树
    
    	#### 		定义：
    
    ​			深度为k的， 有n个结点的二叉树， 当且仅当其 每一个结点都与深度为K的满二叉树中编号从1至n的结		点一一对应时， 称之为完全二叉树。
    
    ​													  ![image-20211210154443537](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20211210154443537.png)
    
    ![image-20211210154459507](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20211210154459507.png)
    
    #### 		特点：
    
    ​		 叶子结点只可能在层次最大的两层上出现；  
    
    ​		 对任一结点， 若其右分支下的子孙的最大层次为l, 则其左分支下的子孙的最大层次必为 i 或 i + 1  
    
    	#### 		性质4   
    
    ​			具有 n 个结点的完全二叉树的深度为![image-20211210153251542](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20211210153251542.png)
    
    	#### 		性质5  
    
    ​			如果对一棵有 n 个结点的完全二叉树（其深度为![image-20211210153251542](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20211210153251542.png)) 的结点按层序编号（从第 1 层到第![image-20211210153251542](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20211210153251542.png) 层， 每层从左到右)， 则对任一结点 i ![image-20211210153633473](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20211210153633473.png), 有 
    
    ​			如果i =1, 则结点 i 是二叉树的根，无双亲；如果 i > 1, 则其双亲PARENT( i )是结点![image-20211210153847642](C:\Users\xyt15\AppData\Roaming\Typora\typora-user-images\image-20211210153847642.png)  
    
    ​			如果2 * i > n, 则结点 i 无左孩子（结点 i 为叶子结点）；否则其左孩子LCHILD ( 1 )是结点 2 * i  
    
    ​			如果2 * i + 1 > n, 则结点 i 无右孩子；否则其右孩子RCHILD ( i )是结点 2 * i + 1。  
    
    ## 二叉树的存储结构
    
    		### 	二叉树的顺序存储表示		
    
    ```c
    //- - - - -二叉树的顺序存储表示－ － － － －
    #define MAXTSIZE 100					//二叉树的最大结点数
    typedef TElemType SqBiTree [MAXTSIZE];	//0 号单元存储根结点
    SqBiTree bt;
    ```
    
    ### 	二叉树的二叉链表存储表示
    
    ```c
    //- - - - -二叉树的二叉链表存储表示－ － － － －
    typedef struct BiTNode
    {
    	TElemType data;							//结点数据域
    	struct BiTNode *lchild, *rchild;		//左右孩子指针
    }BiTNode,*BiTree;
    ```
    
    
    
    ## 遍历二叉树
    
    ### 	定义
    
    ​		遍历二叉树(traversing binary tree)是指按某条搜索路径巡访树中每个结点，使得每个结点
    均被访问一次，而且仅被访问一次。  
    
    	### 	遍历操作
    
    ​		先序遍历二叉树的操作定义如下：
    ​			若二叉树为空，则空操作；否则
    ​			(I)访问根结点；
    ​			(2)先序遍历左子树；
    ​			(3)先序遍历右子树。
    
    ​		中序遍历二叉树的操作定义如下：
    ​			若二叉树为空，则空操作；否则
    ​			(I)中序遍历左子树；
    ​			(2)访问根结点；
    ​			(3)中序遍历右子树。
    
    ​		后序遍历二叉树的操作定义如下：
    ​			若二叉树为空，则空操作；否则
    ​			(I)后序遍历左子树；
    ​			(2)后序遍历右子树；
    ​			(3)访问根结点。  
    
    ### 	中序遍历算法
    
    		#### 			递归
    
    ##### 					算法描述
    
    ```c
    void InOrderTraverse(BiTree T)
    {//中序遍历二叉树T的递归算法
    	if{T) //若二叉树非空
    	{
    		InOrderTraverse(T->lchild); 	//中序遍历左子树
    		cout << T -> data; 				//访问根结点
    		InOrderTraverse(T->rchild);		//中序遍历右子树
    	}
    }                
    ```
    
    #### 			非递归
    
    					##### 					算法步骤
    
    ​				初始化一个空栈 S, 指针p指向根结点
    
    ​				申请一个结点空间 q , 用来存放栈顶弹出的元素
    
    ​				当 p 非空或者栈 S 非空时，循环执行以下操作：
    ​					• 如果 p 非空，则将 p 进栈，p 指向该结点的左孩子
    ​					• 如果 p 为空，则 弹出栈顶元素并访间，将 p 指向该结点的右孩子
    
    ##### 					算法描述
    
    ```c
    void InOrderTraverse(BiTree T)
    {//中序遍历二叉树T的非递归算法
    	InitStack(S);
        p = T;
    	q = new BiTNode;
    	while(p || !StackEmpty (S))
    	{
    		if(p)						//p非空
    		{
    			Push(S,p);				//根指针进栈
    			p = p -> lchild;		//根指针进栈 ， 遍历左子树
            }
    		else						//p为空
            {
    			PoP(S,q);				//退栈
    			cout<< q -> data;		//访问根结点
    			p = q -> rchild;		//遍历右子树
    		}
    	}
    }
    ```
    
    ### 	复制二叉树算法
    
    #### 			算法描述
    
    ​				如果是空树， 递归结束， 否则执行以下操作：
    ​					• 申请一个新结点空间， 复制根结点；
    ​					• 递归复制左子树；
    ​					• 递归复制右子树。  
    
    
    
    #### 			算法步骤
    
    ```c
    void Copy(BiTree T,BiTree &NewT)
    {//复制一棵和T完全相同的二叉树
    	if(T==NULL)									//如果是空树， 递归结束
    	{
    		NewT = NULL;
    		return;
        }
    	else
        {
    		NewT = new BiTNode;
    		NewT -> data = T -> data;				//复制根结点
    		Copy(T -> lchild, NewT -> lchild);		//递归复制左子树
    		Copy(T -> rchild, NewT -> rchild);		//递归复制右子树
        }
    }
    ```
    
    ### 	计算二叉树深度算法
    
    		#### 			算法步骤
    
    ​				如果是空树， 递归结束， 深度为0, 否则执行以下操作：
    ​					• 递归计算左子树的深度记为 m
    ​					• 递归计算右子树的深度记为 n
    ​					• 如果 m 大于 n, 二叉树的深度为 m + 1, 否则为 n + 1
    
    
    
    #### 			算法描述
    
    ```c
    int Depth(BiTree T)
    {//计算二叉树T的深度
    	if(T == NULL) 				//如果是空树，深度为0, 递归结束
        	return 0;
    	else
    	{
    		m = Depth(T -> lchild);		//递归计算左子树的深度记为m
    		n = Depth(T -> rchild);		//递归计算右子树的深度记为n
    		if(m > n) 					//二叉树的深度为m与n的较大者加1
      	  		return(m + l);
        	else
            	return(n + l);
     	}
    }
    ```
    
    